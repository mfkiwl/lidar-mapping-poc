{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"a { color: black !important; } Task List \u2693\ufe0e Study reference project Analyze hardware components Analyze software source code Design system architecture Hardware block diagram Software architecture Get hardware components Rover's parts Base's parts Other stuffs for development Gather documents Develop Rover Hardware work Power supply Component wiring GNSS Emulator Output PPS Output GPRMC Output GNGGA Output OBSVMA Implement Lidar Mapping ROS application on Jetson Nano Dev Kit Install L4T OS Install ROS platform Install Livox SDK Install Livox ROS driver Create Lidar Mapping package Read GNSS input Configure UART ports Enable Time Sync in Livox ROS driver Read GNGGA messages and publish to the Mapping module Read GNSS correction from Base Configure SPI port Read GNSS correction from nRF24 Forward GNSS correction to GNSS module Read IMU input Modify DK-20789 to output processed Rotation Vector Read IMU and publish to the Mapping module Implement Mapping module Read Lidar point-cloud and extract timestamp Read GNSS position and extract timestamp Read IMU pose and extract timestamp Align data using timestamp Apply position on point-cloud Apply pose on points Publish mapped point-cloud Output systems status Configure I2C port Output system status to OLED Enable Auto-mount USB Configure Rover to log Observation Save Lidar point-cloud to USB Save GNSS observation to USB Save IMU pose to USB Develop Base Station Hardware work Power supply Component wiring Implement Base application on Raspberry Pi 3 B+ Install Raspbian OS Read GNSS correction input Configure UART port Read RTCM3 messages Output GNSS correction Configure SPI port Output RTCM3 messages to nRF24 Enable Auto-mount USB Save GNSS correction to USB Output systems status Configure I2C port Output system status to OLED Develop Post-Processing method Convert GNSS Observation data to RINEX format Build RTKLib module to process data Re-apply Mapping on processed Positions","title":"Home"},{"location":"#task-list","text":"Study reference project Analyze hardware components Analyze software source code Design system architecture Hardware block diagram Software architecture Get hardware components Rover's parts Base's parts Other stuffs for development Gather documents Develop Rover Hardware work Power supply Component wiring GNSS Emulator Output PPS Output GPRMC Output GNGGA Output OBSVMA Implement Lidar Mapping ROS application on Jetson Nano Dev Kit Install L4T OS Install ROS platform Install Livox SDK Install Livox ROS driver Create Lidar Mapping package Read GNSS input Configure UART ports Enable Time Sync in Livox ROS driver Read GNGGA messages and publish to the Mapping module Read GNSS correction from Base Configure SPI port Read GNSS correction from nRF24 Forward GNSS correction to GNSS module Read IMU input Modify DK-20789 to output processed Rotation Vector Read IMU and publish to the Mapping module Implement Mapping module Read Lidar point-cloud and extract timestamp Read GNSS position and extract timestamp Read IMU pose and extract timestamp Align data using timestamp Apply position on point-cloud Apply pose on points Publish mapped point-cloud Output systems status Configure I2C port Output system status to OLED Enable Auto-mount USB Configure Rover to log Observation Save Lidar point-cloud to USB Save GNSS observation to USB Save IMU pose to USB Develop Base Station Hardware work Power supply Component wiring Implement Base application on Raspberry Pi 3 B+ Install Raspbian OS Read GNSS correction input Configure UART port Read RTCM3 messages Output GNSS correction Configure SPI port Output RTCM3 messages to nRF24 Enable Auto-mount USB Save GNSS correction to USB Output systems status Configure I2C port Output system status to OLED Develop Post-Processing method Convert GNSS Observation data to RINEX format Build RTKLib module to process data Re-apply Mapping on processed Positions","title":"Task List"},{"location":"components/","text":".md-typeset .admonition.specs, .md-typeset details.specs { margin: -2rem 0 0 -1.2rem; } .md-typeset .admonition.specs > .admonition-title::before, .md-typeset details.specs > summary::before{ visibility: hidden; } The system has 2 main parts: Rover is mounted on an RC Car or Drone to scan an area and map the captured point-cloud. Base acts as a stationary point which provide positioning correction to Rover for better accuracy. var expanded = false; function toggleDetails() { expanded = !expanded; self.checked = expanded; var d = document.getElementsByTagName(\"details\"); Array.from(d).forEach( function(obj, idx) { obj.open = expanded; }); var i = document.querySelectorAll(\"input.specs\"); console.log(i) Array.from(i).forEach( function(obj, idx) { obj.checked = expanded; }); } Rover \u2693\ufe0e Show specification Livox Lidar Mid-40 100,000 points per second POV: 38.4\u00b0 circular Upto 260m @ 80% reflectivity Livox Converter 1.0 : Power, Ethernet, Sync RS485. > It's better to get Converter 2.0 Jetson Nano Developer Kit CPU Quad-core ARM A57 @ 1.43 GHz GPU 128-core Maxwell RAM 4 GB 64-bit LPDDR4 25.6 GB/s Gigabit Ethernet, M.2 Key E 4x USB 3.0, USB 2.0 Micro-B GPIO, I2C, I2S, SPI, UARTs MicroSD Card Should have at least 32 GB at high speed (V30) for saving point louds Sandisk Ultra 16 GB, class 10, SDHC I Unicorecomm GNSS UB482 GPS L1/L2 + BDS B1/B2 + GLONASS L1/ L2 + Galileo E1/E5b + QZSS L1/L2 Two antennas, support heading 20 Hz data output rate Ethernet, serial port, SPI, 1PPS Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MMCX Male UB482 has MMCX (Mini-MCX) Female connector HX-CH7604A has SMA Male connector InvenSense DK-20789 7-axis motion sensor Embedded Microchip G55 MCU and debugger Embedded Motion Drivers Rechargeable Battery 16V with 2000 mAh Peak current at 4 A DC-DC Converter Except Lidar, all other boards use 5V Peak current at 4 A USB WiFi dongle TP-Link WN725N 150Mbps 802.11b/g/n, Internal antenna Ad-Hoc / Infrastructure Mode WiFi router No need this component if using a USB WiFi dongle connected to the Jetson board, and Lidar is connected directly with it. 4-port LAN 2 x Ethernet Cable Either connect Lidar to the Router or connect to the Jetson board directly after setting up static IPs on both sides nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to RS485 No need this component if using Livox Converter 2.0 5V operation, differential voltage >= 200 mV 3x USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface Base \u2693\ufe0e Show specification Raspberry Pi 3 B+ This can be repalaced by a MCU as Base only needs to log data and transmit RTCM3 messages Broadcom BCM2837B0, Cortex-A53 (ARMv8) 64-bit SoC @ 1.4GHz 1GB LPDDR2 SDRAM 2.4GHz and 5GHz IEEE 802.11.b/g/n/ac wireless LAN, Bluetooth 4.2, BLE Gigabit Ethernet over USB 2.0 4 USB 2.0 ports GPIO, I2C, I2S, SPI, UARTs Unicorecomm GNSS UB4B0M Should cover the same constellation system of the Rover GPS L1/L2/L5 + BDS B1/B2/B3 + GLONASS L1/L2 + Galileo E1/E5a/E5b+ QZSS L1/L2/L5 UARTs, 1PPS Onboard MEMS integrated navigation ?? Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MCX Male UB4B0M has MCX Female connector HX-CH7604A has SMA Male connector MicroSD Card Sandisk Ultra 16 GB, class 10, SDHC I Rechargeable Battery 5V with 2000 mAh Peak current at 2 A nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface Other stuff \u2693\ufe0e Show specification STM32 Dev board Emulate GNSS data when GPS is not available (in house, or cloudy days) Jump 2.0mm Unicorecomm GNSS modules use headers at 2.0mm pitch Remote Control Car with large base Mount Rover on the car for testing","title":"Components"},{"location":"components/#rover","text":"Show specification Livox Lidar Mid-40 100,000 points per second POV: 38.4\u00b0 circular Upto 260m @ 80% reflectivity Livox Converter 1.0 : Power, Ethernet, Sync RS485. > It's better to get Converter 2.0 Jetson Nano Developer Kit CPU Quad-core ARM A57 @ 1.43 GHz GPU 128-core Maxwell RAM 4 GB 64-bit LPDDR4 25.6 GB/s Gigabit Ethernet, M.2 Key E 4x USB 3.0, USB 2.0 Micro-B GPIO, I2C, I2S, SPI, UARTs MicroSD Card Should have at least 32 GB at high speed (V30) for saving point louds Sandisk Ultra 16 GB, class 10, SDHC I Unicorecomm GNSS UB482 GPS L1/L2 + BDS B1/B2 + GLONASS L1/ L2 + Galileo E1/E5b + QZSS L1/L2 Two antennas, support heading 20 Hz data output rate Ethernet, serial port, SPI, 1PPS Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MMCX Male UB482 has MMCX (Mini-MCX) Female connector HX-CH7604A has SMA Male connector InvenSense DK-20789 7-axis motion sensor Embedded Microchip G55 MCU and debugger Embedded Motion Drivers Rechargeable Battery 16V with 2000 mAh Peak current at 4 A DC-DC Converter Except Lidar, all other boards use 5V Peak current at 4 A USB WiFi dongle TP-Link WN725N 150Mbps 802.11b/g/n, Internal antenna Ad-Hoc / Infrastructure Mode WiFi router No need this component if using a USB WiFi dongle connected to the Jetson board, and Lidar is connected directly with it. 4-port LAN 2 x Ethernet Cable Either connect Lidar to the Router or connect to the Jetson board directly after setting up static IPs on both sides nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to RS485 No need this component if using Livox Converter 2.0 5V operation, differential voltage >= 200 mV 3x USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface","title":"Rover"},{"location":"components/#base","text":"Show specification Raspberry Pi 3 B+ This can be repalaced by a MCU as Base only needs to log data and transmit RTCM3 messages Broadcom BCM2837B0, Cortex-A53 (ARMv8) 64-bit SoC @ 1.4GHz 1GB LPDDR2 SDRAM 2.4GHz and 5GHz IEEE 802.11.b/g/n/ac wireless LAN, Bluetooth 4.2, BLE Gigabit Ethernet over USB 2.0 4 USB 2.0 ports GPIO, I2C, I2S, SPI, UARTs Unicorecomm GNSS UB4B0M Should cover the same constellation system of the Rover GPS L1/L2/L5 + BDS B1/B2/B3 + GLONASS L1/L2 + Galileo E1/E5a/E5b+ QZSS L1/L2/L5 UARTs, 1PPS Onboard MEMS integrated navigation ?? Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MCX Male UB4B0M has MCX Female connector HX-CH7604A has SMA Male connector MicroSD Card Sandisk Ultra 16 GB, class 10, SDHC I Rechargeable Battery 5V with 2000 mAh Peak current at 2 A nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface","title":"Base"},{"location":"components/#other-stuff","text":"Show specification STM32 Dev board Emulate GNSS data when GPS is not available (in house, or cloudy days) Jump 2.0mm Unicorecomm GNSS modules use headers at 2.0mm pitch Remote Control Car with large base Mount Rover on the car for testing","title":"Other stuff"},{"location":"design/","text":"Based on study of a reference project from Livox. 1. Hardware \u2693\ufe0e Refer to the list of Components . 1.1. Block diagram \u2693\ufe0e Rover's components Base's components Notes : All modules, except Livox's, are 3.3 V level, so they are can be connected directly. This helps to ommit USB TTL-to-COM. Raspberry Pi 3 B+ has on-board WiFi module 1.2. Power supply \u2693\ufe0e Rover's power supply Base's power supply Notes : The input voltage of Livox Converter is 10 ~ 16 VDC, therefore, an 1N5400 diode can be connected in serial to reduce voltage to under 16 VDC. 2. Software \u2693\ufe0e","title":"System design"},{"location":"design/#1-hardware","text":"Refer to the list of Components .","title":"1. Hardware"},{"location":"design/#11-block-diagram","text":"Rover's components Base's components Notes : All modules, except Livox's, are 3.3 V level, so they are can be connected directly. This helps to ommit USB TTL-to-COM. Raspberry Pi 3 B+ has on-board WiFi module","title":"1.1. Block diagram"},{"location":"design/#12-power-supply","text":"Rover's power supply Base's power supply Notes : The input voltage of Livox Converter is 10 ~ 16 VDC, therefore, an 1N5400 diode can be connected in serial to reduce voltage to under 16 VDC.","title":"1.2. Power supply"},{"location":"design/#2-software","text":"","title":"2. Software"},{"location":"gnss-emulator/","text":"1. Requirements \u2693\ufe0e The emulator should output: PPS signal at 1 Hz, 25% duty cycle GPRMC at 1 Hz, about 83 bytes per message GNGGA at 1 Hz, about 86 bytes per message OBSVMA at 1 Hz, about 2700 bytes per message All messages are aligned to the rising edge of PPS signal 2. Configuration \u2693\ufe0e The main MCU is STM32F103C8Tx , mounted on a Blue Pill dev board. 2.1. System Clock \u2693\ufe0e Use an external 8 MHz crystal to make 72 MHz system clock. 2.2. PPS Signal \u2693\ufe0e PPS signal will be output by PWM function of the Timer 1 module: Clock source: Internal Clock, at 72 MHz Channel 1: PWM Generation CH1 Prescaler PSC : 36000-1 Counter Period AAR : 2000-1 PWM Generation Channel 1: Mode: 1 (Positive at start) Pulse: 500 ( 25% of AAR) Interrtupt: on Update 2.3. UART Protocol \u2693\ufe0e Using a setting of 8-N-1 (8 bit, No parity, 1 stop bit), each byte requires 10 bits. Baudrate at 115200 bit-per-second means the speed is 11520 byte-per-second. At this speed, 4 OBSVMA messages can be transfer completely in a second. All messages on UART ports will be send in DMA mode which allows sending data concurrently. Interrupt must be enabled to make DMA function work properly. The UART1, UART2, UART3 are configured as: Mode: Asynchronous Hardware Flow Control: Disabled Baud Rate: 115200 bps, 8-N-1 Interrupt: Enabled DMA: Channel: TX Direction: Memory to Peripheral , Mode: Normal Data width: Byte Increment Address: Memory only 2.4. Messages \u2693\ufe0e All messages are pre-filled, only some necessary parts will be modified to reduce processing time. UTC Time must be updated every second in GPRMC and GNGGA GPRMC message must have correct CRC value Example message : $GPRMC , 000000.00 , A , 2057.59811106 , N , 10546.17288672 , E , 0.109 , 193.8 , 200821 , 1.5 , W , A * 21 $GNGGA , 000000.00 , 2057.59811106 , N , 10546.17288672 , E , 1 , 18 , 2.2 , 16.5017 , M , -28.2478 , M ,, * 61 #OBSVMA,92,GPS,FINE,2172,171764000,0,0,18,4;36,0,6,21338531.558,-112134733.414741,4,50,1574.771,4911,0,120.007,08181c24,0,6,21338529.258,-87377704.069472,6,62,1227.131,4548,0,124.007,05381c2b,0,14,20319924.197,-106781918.629190,7,69,493.942,4417,0,120.007,08181c44,0,14,20319920.803,-83206684.730617,17,147,384.872,3805,0,120.007,01301c4b,0,17,21945245.330,-115323032.576040,7,72,257.824,4358,0,120.007,08181c64,0,17,21945240.311,-89862089.990482,16,133,200.906,3462,0,124.007,05381c6b,0,28,20944473.540,-110063951.781589,13,108,1803.692,3715,0,120.007,08181c84,0,28,20944484.235,-85764160.734407,109,1499,1405.503,2691,0,0.000,0130108b,0,30,22761674.739,-119613418.379433,15,129,-2607.156,3502,0,120.007,08181ca4,0,34,36431345.429,-191447981.578579,17,145,723.997,3348,0,61.020,08181de4,0,34,36431346.104,-149180346.656281,25,213,564.374,3018,0,64.000,05381deb,0,51,20101165.397,-107150539.530252,9,84,2120.845,4104,0,98.020,08191c24,0,51,20101162.656,-83339293.141160,15,128,1649.603,3515,0,98.020,00b91c2b,9,61,20777773.795,-111108092.002339,8,76,-1034.863,4278,0,98.020,08191cc4,9,61,20777767.903,-86417385.183432,8,76,-804.847,4262,0,98.020,00b91ccb,5,50,19929653.269,-106423234.539838,13,113,-2263.388,3668,0,97.000,08191ce4,5,50,19929648.776,-82773623.659687,12,101,-1760.391,3782,0,99.000,00b91ceb,0,2,36696586.693,-191088755.879035,6,67,237.164,4442,0,124.007,0c1c1c24,0,2,36696569.181,-147761876.696199,10,87,183.488,4043,0,124.007,063c1c2b,0,3,36400030.347,-189544510.384493,4,54,258.795,4714,0,124.007,0c1c1c44,0,3,36400015.890,-146567780.955546,7,73,199.972,4327,0,124.007,063c1c4b,0,7,35994436.346,-187432473.995137,9,84,598.363,4120,0,124.007,081c1c64,0,7,35994419.240,-144934613.705130,12,107,462.734,3724,0,124.007,023c1c6b,0,8,36373710.476,-189407461.691094,6,67,40.827,4441,0,124.007,081c1c84,0,8,36373693.708,-146461793.687978,9,81,31.530,4163,0,124.007,023c1c8b,0,10,36089453.781,-187927246.296557,11,94,817.209,3920,0,124.007,081c1ca4,0,10,36089437.896,-145317213.651417,13,112,632.177,3675,0,124.007,023c1cab,0,13,36416396.770,-189629741.119410,6,67,547.278,4446,0,124.007,081c1cc4,0,13,36416388.298,-146633708.070459,11,94,423.233,3903,0,124.007,023c1ccb,0,30,22898967.933,-119240944.705313,17,143,339.060,3368,0,124.987,081c1ce4,0,56,42284061.567,-220184200.279297,6,65,527.536,4481,0,118.007,081c1d04,0,38,35881839.606,-186846150.560976,4,51,183.397,4775,0,118.007,081c1d24,0,25,23468075.990,-123325572.189710,4,50,49.187,4832,0,119.007,085b1c44,0,25,23468072.270,-94496203.038075,7,73,37.687,4331,0,119.007,02331c40,0,36,23920511.872,-125703139.336542,6,66,-175.856,4472,0,100.987,085b1d44,0,36,23920511.685,-96317987.477716,9,84,-134.684,4112,0,101.007,02331d40*a302f998 Pin map on STM32F103C8Tx 3. Implementation \u2693\ufe0e Checkout GitHub repo: https://github.com/vuquangtrong/lidar-mapping-poc.gnss_emu.git . Result : Output of GNSS emulator Concurent outputs","title":"GNSS emulator"},{"location":"gnss-emulator/#1-requirements","text":"The emulator should output: PPS signal at 1 Hz, 25% duty cycle GPRMC at 1 Hz, about 83 bytes per message GNGGA at 1 Hz, about 86 bytes per message OBSVMA at 1 Hz, about 2700 bytes per message All messages are aligned to the rising edge of PPS signal","title":"1. Requirements"},{"location":"gnss-emulator/#2-configuration","text":"The main MCU is STM32F103C8Tx , mounted on a Blue Pill dev board.","title":"2. Configuration"},{"location":"gnss-emulator/#21-system-clock","text":"Use an external 8 MHz crystal to make 72 MHz system clock.","title":"2.1. System Clock"},{"location":"gnss-emulator/#22-pps-signal","text":"PPS signal will be output by PWM function of the Timer 1 module: Clock source: Internal Clock, at 72 MHz Channel 1: PWM Generation CH1 Prescaler PSC : 36000-1 Counter Period AAR : 2000-1 PWM Generation Channel 1: Mode: 1 (Positive at start) Pulse: 500 ( 25% of AAR) Interrtupt: on Update","title":"2.2. PPS Signal"},{"location":"gnss-emulator/#23-uart-protocol","text":"Using a setting of 8-N-1 (8 bit, No parity, 1 stop bit), each byte requires 10 bits. Baudrate at 115200 bit-per-second means the speed is 11520 byte-per-second. At this speed, 4 OBSVMA messages can be transfer completely in a second. All messages on UART ports will be send in DMA mode which allows sending data concurrently. Interrupt must be enabled to make DMA function work properly. The UART1, UART2, UART3 are configured as: Mode: Asynchronous Hardware Flow Control: Disabled Baud Rate: 115200 bps, 8-N-1 Interrupt: Enabled DMA: Channel: TX Direction: Memory to Peripheral , Mode: Normal Data width: Byte Increment Address: Memory only","title":"2.3. UART Protocol"},{"location":"gnss-emulator/#24-messages","text":"All messages are pre-filled, only some necessary parts will be modified to reduce processing time. UTC Time must be updated every second in GPRMC and GNGGA GPRMC message must have correct CRC value Example message : $GPRMC , 000000.00 , A , 2057.59811106 , N , 10546.17288672 , E , 0.109 , 193.8 , 200821 , 1.5 , W , A * 21 $GNGGA , 000000.00 , 2057.59811106 , N , 10546.17288672 , E , 1 , 18 , 2.2 , 16.5017 , M , -28.2478 , M ,, * 61 #OBSVMA,92,GPS,FINE,2172,171764000,0,0,18,4;36,0,6,21338531.558,-112134733.414741,4,50,1574.771,4911,0,120.007,08181c24,0,6,21338529.258,-87377704.069472,6,62,1227.131,4548,0,124.007,05381c2b,0,14,20319924.197,-106781918.629190,7,69,493.942,4417,0,120.007,08181c44,0,14,20319920.803,-83206684.730617,17,147,384.872,3805,0,120.007,01301c4b,0,17,21945245.330,-115323032.576040,7,72,257.824,4358,0,120.007,08181c64,0,17,21945240.311,-89862089.990482,16,133,200.906,3462,0,124.007,05381c6b,0,28,20944473.540,-110063951.781589,13,108,1803.692,3715,0,120.007,08181c84,0,28,20944484.235,-85764160.734407,109,1499,1405.503,2691,0,0.000,0130108b,0,30,22761674.739,-119613418.379433,15,129,-2607.156,3502,0,120.007,08181ca4,0,34,36431345.429,-191447981.578579,17,145,723.997,3348,0,61.020,08181de4,0,34,36431346.104,-149180346.656281,25,213,564.374,3018,0,64.000,05381deb,0,51,20101165.397,-107150539.530252,9,84,2120.845,4104,0,98.020,08191c24,0,51,20101162.656,-83339293.141160,15,128,1649.603,3515,0,98.020,00b91c2b,9,61,20777773.795,-111108092.002339,8,76,-1034.863,4278,0,98.020,08191cc4,9,61,20777767.903,-86417385.183432,8,76,-804.847,4262,0,98.020,00b91ccb,5,50,19929653.269,-106423234.539838,13,113,-2263.388,3668,0,97.000,08191ce4,5,50,19929648.776,-82773623.659687,12,101,-1760.391,3782,0,99.000,00b91ceb,0,2,36696586.693,-191088755.879035,6,67,237.164,4442,0,124.007,0c1c1c24,0,2,36696569.181,-147761876.696199,10,87,183.488,4043,0,124.007,063c1c2b,0,3,36400030.347,-189544510.384493,4,54,258.795,4714,0,124.007,0c1c1c44,0,3,36400015.890,-146567780.955546,7,73,199.972,4327,0,124.007,063c1c4b,0,7,35994436.346,-187432473.995137,9,84,598.363,4120,0,124.007,081c1c64,0,7,35994419.240,-144934613.705130,12,107,462.734,3724,0,124.007,023c1c6b,0,8,36373710.476,-189407461.691094,6,67,40.827,4441,0,124.007,081c1c84,0,8,36373693.708,-146461793.687978,9,81,31.530,4163,0,124.007,023c1c8b,0,10,36089453.781,-187927246.296557,11,94,817.209,3920,0,124.007,081c1ca4,0,10,36089437.896,-145317213.651417,13,112,632.177,3675,0,124.007,023c1cab,0,13,36416396.770,-189629741.119410,6,67,547.278,4446,0,124.007,081c1cc4,0,13,36416388.298,-146633708.070459,11,94,423.233,3903,0,124.007,023c1ccb,0,30,22898967.933,-119240944.705313,17,143,339.060,3368,0,124.987,081c1ce4,0,56,42284061.567,-220184200.279297,6,65,527.536,4481,0,118.007,081c1d04,0,38,35881839.606,-186846150.560976,4,51,183.397,4775,0,118.007,081c1d24,0,25,23468075.990,-123325572.189710,4,50,49.187,4832,0,119.007,085b1c44,0,25,23468072.270,-94496203.038075,7,73,37.687,4331,0,119.007,02331c40,0,36,23920511.872,-125703139.336542,6,66,-175.856,4472,0,100.987,085b1d44,0,36,23920511.685,-96317987.477716,9,84,-134.684,4112,0,101.007,02331d40*a302f998 Pin map on STM32F103C8Tx","title":"2.4. Messages"},{"location":"gnss-emulator/#3-implementation","text":"Checkout GitHub repo: https://github.com/vuquangtrong/lidar-mapping-poc.gnss_emu.git . Result : Output of GNSS emulator Concurent outputs","title":"3. Implementation"},{"location":"reference/","text":"1. Overview \u2693\ufe0e The official guide and source code is hosted in livox_high_precision_mapping This project aims to stick geographical information into a point cloud. The data from GNSS and INS module is used to calculate high precision position of every point captured from the Lidar. The sample project uses a Livox Mid-40 lidar and an APX-15 GNSS-INS module. The system block diagram looks like below: Livox mapping using APX-15 The APX-15 module sends PPS pulse to Livox, and sends GPS timestamp in GNRMC messages to the Manifold 2 computer which forwards timestamp to Livox through an Ethernet connection The APX-15 module sends Trimble's GSOF messages which contains GNSS location data and IMU information to the Manifold 2 The Livox Mid-40, gets PPS and GNRMC timestamp then sends point cloud message to the Manifold 2 on the Ethernet connection The Manifold2 processes GNSS, IMU and pointcloud together to create a geo-referenced pointcloud. 2. Mapping package \u2693\ufe0e The data flow is described in the below diagram: Lidar Mapping system calls and data flow User configuration points: Turn on Timestamp Synchronization and set GNRMC input device in livox_lidar_config.json file Set GSOF input device in apx15.launch file Run the mapping_online.launch file to generate point cloud data in the pointcloud2 format that combines the IMU pose and GNSS position: roslaunch livox_mapping mapping_online.launch 3. APX-15 Node \u2693\ufe0e The APX-15 node reads GSOF messages from APX and extract the GNSS and IMU data from the Report Packet (0x40 \u2014 GENOUT) . There are 3 interesting message types: UTC message (ID = 16) INS Navigation message (ID = 49) INS RMS message (ID = 50) These extracted information will be used to make sensor_msgs::NavSatFix and sensor_msgs::Imu messages which are posted to the mapping node. Extract data from APX-15 GSOF message 4. Mapping node \u2693\ufe0e The mapping node gets the pointcloud from the Lidar ROS driver node, the GNSS and IMU data from the APX-15 node and processes them together: Store pointcloud with timestamp Store GNSS with timestamp Store IMU with timestamp Align packets using timestamp Apply IMU to GNSS point, and stick geographical information to pointcloud Combine position and pose into pointcloud","title":"Reference"},{"location":"reference/#1-overview","text":"The official guide and source code is hosted in livox_high_precision_mapping This project aims to stick geographical information into a point cloud. The data from GNSS and INS module is used to calculate high precision position of every point captured from the Lidar. The sample project uses a Livox Mid-40 lidar and an APX-15 GNSS-INS module. The system block diagram looks like below: Livox mapping using APX-15 The APX-15 module sends PPS pulse to Livox, and sends GPS timestamp in GNRMC messages to the Manifold 2 computer which forwards timestamp to Livox through an Ethernet connection The APX-15 module sends Trimble's GSOF messages which contains GNSS location data and IMU information to the Manifold 2 The Livox Mid-40, gets PPS and GNRMC timestamp then sends point cloud message to the Manifold 2 on the Ethernet connection The Manifold2 processes GNSS, IMU and pointcloud together to create a geo-referenced pointcloud.","title":"1. Overview"},{"location":"reference/#2-mapping-package","text":"The data flow is described in the below diagram: Lidar Mapping system calls and data flow User configuration points: Turn on Timestamp Synchronization and set GNRMC input device in livox_lidar_config.json file Set GSOF input device in apx15.launch file Run the mapping_online.launch file to generate point cloud data in the pointcloud2 format that combines the IMU pose and GNSS position: roslaunch livox_mapping mapping_online.launch","title":"2. Mapping package"},{"location":"reference/#3-apx-15-node","text":"The APX-15 node reads GSOF messages from APX and extract the GNSS and IMU data from the Report Packet (0x40 \u2014 GENOUT) . There are 3 interesting message types: UTC message (ID = 16) INS Navigation message (ID = 49) INS RMS message (ID = 50) These extracted information will be used to make sensor_msgs::NavSatFix and sensor_msgs::Imu messages which are posted to the mapping node. Extract data from APX-15 GSOF message","title":"3. APX-15 Node"},{"location":"reference/#4-mapping-node","text":"The mapping node gets the pointcloud from the Lidar ROS driver node, the GNSS and IMU data from the APX-15 node and processes them together: Store pointcloud with timestamp Store GNSS with timestamp Store IMU with timestamp Align packets using timestamp Apply IMU to GNSS point, and stick geographical information to pointcloud Combine position and pose into pointcloud","title":"4. Mapping node"}]}