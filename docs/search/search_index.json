{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"a { color: black !important; } Task List \u2693\ufe0e Study reference project Analyze hardware components Analyze software source code Design system architecture Hardware block diagram Pinout and wiring Software architecture Get hardware components Rover's parts Base's parts Other stuffs for development Gather documents Develop Rover Hardware work Power supply Component wiring GNSS Output PPS Output GPRMC Output GNGGA Output OBSVMA Testing with 20 Hz GNGGA and 1 Hz OBSVMA IMU Configure DK-20789 project Modify DK-20789 to output raw IMU data Modify DK-20789 to output processed Rotation Vector Implement Lidar Mapping ROS application on Jetson Nano Dev Kit Install L4T OS Install ROS platform Install Livox SDK Install Livox ROS driver Setup Ethernet connection with Livox Create Lidar Mapping package Read GNSS input Configure UART ports Enable Time Sync in Livox ROS driver Read GNGGA messages and publish to the Mapping module Read GNSS correction from Base Configure SPI port Add nRF24 driver Read GNSS correction from nRF24 Forward GNSS correction to GNSS module Read IMU input Read IMU and publish to the Mapping module Implement Mapping module Read Lidar point-cloud and extract timestamp Read GNSS position and extract timestamp Read IMU pose and extract timestamp Align data using timestamp Apply position on point-cloud Apply pose on points Publish mapped point-cloud Output systems status Configure I2C port Add OLED driver Output system status to OLED Enable Auto-mount USB Configure Rover to log Observation Save Lidar point-cloud to USB Save GNSS observation to USB Save IMU pose to USB Develop Base Station Hardware work Power supply Component wiring Implement Base application on Raspberry Pi 3 B+ Install Raspbian OS Read GNSS correction input Configure UART port Read RTCM3 messages Output GNSS correction Configure SPI port Add nRF24 driver Output RTCM3 messages to nRF24 Enable Auto-mount USB Save GNSS correction to USB Output systems status Configure I2C port Add OLED driver Output system status to OLED Develop Post-Processing method Convert GNSS Observation data to RINEX format Request Unicorecomm Converter Integrate Unicorecomm Converter Build RTKLib module to process data Re-apply Mapping on processed Positions","title":"Home"},{"location":"#task-list","text":"Study reference project Analyze hardware components Analyze software source code Design system architecture Hardware block diagram Pinout and wiring Software architecture Get hardware components Rover's parts Base's parts Other stuffs for development Gather documents Develop Rover Hardware work Power supply Component wiring GNSS Output PPS Output GPRMC Output GNGGA Output OBSVMA Testing with 20 Hz GNGGA and 1 Hz OBSVMA IMU Configure DK-20789 project Modify DK-20789 to output raw IMU data Modify DK-20789 to output processed Rotation Vector Implement Lidar Mapping ROS application on Jetson Nano Dev Kit Install L4T OS Install ROS platform Install Livox SDK Install Livox ROS driver Setup Ethernet connection with Livox Create Lidar Mapping package Read GNSS input Configure UART ports Enable Time Sync in Livox ROS driver Read GNGGA messages and publish to the Mapping module Read GNSS correction from Base Configure SPI port Add nRF24 driver Read GNSS correction from nRF24 Forward GNSS correction to GNSS module Read IMU input Read IMU and publish to the Mapping module Implement Mapping module Read Lidar point-cloud and extract timestamp Read GNSS position and extract timestamp Read IMU pose and extract timestamp Align data using timestamp Apply position on point-cloud Apply pose on points Publish mapped point-cloud Output systems status Configure I2C port Add OLED driver Output system status to OLED Enable Auto-mount USB Configure Rover to log Observation Save Lidar point-cloud to USB Save GNSS observation to USB Save IMU pose to USB Develop Base Station Hardware work Power supply Component wiring Implement Base application on Raspberry Pi 3 B+ Install Raspbian OS Read GNSS correction input Configure UART port Read RTCM3 messages Output GNSS correction Configure SPI port Add nRF24 driver Output RTCM3 messages to nRF24 Enable Auto-mount USB Save GNSS correction to USB Output systems status Configure I2C port Add OLED driver Output system status to OLED Develop Post-Processing method Convert GNSS Observation data to RINEX format Request Unicorecomm Converter Integrate Unicorecomm Converter Build RTKLib module to process data Re-apply Mapping on processed Positions","title":"Task List"},{"location":"base/","text":"1. Operating System \u2693\ufe0e Download Raspberry Pi Imager and install it. Run the Pi Imager, and select the Desktop version but without recommended software. Press Ctrl + Shift + X to show the advanced menu, fill some settings as below: Hostname: base SSH: yes and set a password WiFi: yes and set a SSID and its password Note to save the options for later use if needed. Alternative method using balenaEtcher Download Raspberry Pi OS image, select Desktop version but without recommended software. Download balenaEtcher and install it, and write the Image in an SD Card. After finishing, re-plug the SD Card. Add an empty file with name ssh into the boot partition to enabled SSH. It is also recommended enabling WiFi network by add a file wpa_supplicant.conf in the boot partition: wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } For the official Raspberry Pi OS, the default username is pi , with password raspberry , on the host raspberrypi . Bonjour is a service from Apple to discovery devices in a network using hostname. Install it and then Pi can be connected using its default hostname raspberrypi.local . SSH Connection With SSH enabled and WiFi network connected, accessing to Raspberry Pi is remotely through SSH. Using any X11-fordwarding SSH, such as MobaXterm, GUI application can be shown in the host PC. Some tweaks can be applied after login: To use some list command, in .bashrc , enable alias for ls command. To disable animation on GUI: gsettings set org.gnome.desktop.interface enable-animations false If eth0 is used, it may take priority of network connection over the wlan0 . If internet is accessible through wlan0 , edit /etc/dhcpcd.conf and add this: interface wlan0 metric 100 Then wireless will have precedence, its default route/gateway will be used. The official tool raspi-config should be used to configure the GPIO on Pi. sudo raspi-config Select Interfacing Options and select below item: SPI > Enable SPI I2C > Enable I2C Arm Serial Port > No login shell > Enable UART After enabling the primary UART, the VPU clock will be set at 250 MHz. Run groups to see the current user is added into groups for using GPIO including gpio , i2c and spi . Raspberry Pi 40-pin header 2. UART Config \u2693\ufe0e Refer to Raspberry Pi UART . There are two types of UART available on the Raspberry Pi - PL011 and mini UART . The PL011 is a capable, broadly 16550-compatible UART, while the mini UART has a reduced feature set. All UARTs on the Raspberry Pi are 3.3V only. The Raspberry Pi 3 has below default UART configuration: Hardware port Type Usage Pin Map Linux Device UART0 PL011 Secondary (Bluetooth), enabled N/A /dev/serial1 UART1 mini UART Primary, disabled GPIO 14 (TX), GPIO 15 (RX) /dev/serial0 That means the exported UART port on GPIO header is a Mini-UART. The problem is the speed of mini-UART port depends on VPU (graphic) Core Frequency. The primary UART is disabled by default. It has to be enabled by running raspi-config to set up interfaces. To get rid of using sudo permission, add current user into the serial group. Run ls -al /dev/tty* to check the user group of ttyS0 , ttyTHS1 . Normally, it is needed to add current user into tty and dialout groups: sudo usermod -a -G tty $USER sudo usermod -a -G dialout $USER sudo reboot UART Testing For testing, a serial terminal must be installed. Choose one of below. putty sudo apt install putty -y putty Follow GUI to run. minicom sudo apt install minicom -y minicom -D /dev/ttyS0 -b 115200 Press Ctrl-A X to exit. picocom sudo apt install picocom -y picocom /dev/ttyS0 -b 115200 Press Ctrl-A and Ctrl-X to exit. screen sudo apt install screen -y screen /dev/ttyS0 115200 Press Ctrl-A K to exit. 3. Module Connection \u2693\ufe0e Refer to below pinout diagram: Base wiring 4. Serial driver \u2693\ufe0e Download source code and build: git clone https://github.com/vuquangtrong/SerialPort.git && \\ cd SerialPort && \\ make && \\ sudo make install An example to communicate with Serial port: // Serial library #include \"serial/SerialPort.h\" #include <unistd.h> #include <stdio.h> #define SERIAL_PORT \"/dev/ttyS0\" int main ( /*int argc, char *argv[]*/ ) { SerialPort serial ; char errorOpening = serial . openDevice ( SERIAL_PORT , 115200 ); if ( errorOpening != 1 ) return errorOpening ; printf ( \"Successful connection to %s \\n \" , SERIAL_PORT ); // Display ASCII characters (from 32 to 128) for ( int c = 32 ; c < 128 ; c ++ ) { serial . writeChar ( c ); usleep ( 10000 ); } // Read lines and print them out char line [ 1024 ]; while ( 1 ) { int n = serial . readBytes ( line , sizeof ( line )); if ( n >= 0 ) { std :: cout << std :: string ( line , n ) << std :: endl ; } } // Close the serial device serial . closeDevice (); return 0 ; } Compile and run: g++ example.cpp -lserial -o example 5. nRF24 driver \u2693\ufe0e Download source code from GitHub and build: git clone https://github.com/vuquangtrong/RF24 && \\ cd RF24 && \\ ./configure --driver = SPIDEV && \\ make && \\ sudo make install SPIDEV must be used to avoid permission error when using default RPi BCM driver Work with the original source code GitHub at https://github.com/nRF24/RF24 . The guide to install in Linux at https://nrf24.github.io/RF24/md_docs_linux_install.html . Download the install.sh file: wget http://tmrh20.github.io/RF24Installer/RPi/install.sh Make it executable: chmod +x install.sh Run it and choose the option: RF24 Core SPIDEV driver ./install.sh Do you want to install GIT using APT (Used to download source code) [y/N]? n Do you want to install the RF24 core library, [y/N]? y Do you want to install the RF24Network library [y/N]? Do you want to install the RF24Mesh library [y/N]? Do you want to install the RF24Gateway library [y/N]? Installing RF24 Repo... *** Install RF24 core using? *** 1.BCM2835 Driver(Performance) 2.SPIDEV(Compatibility, Default) 3.WiringPi(Its WiringPi!) 4.MRAA(Intel Devices) 5.LittleWire 2 ... [Installing Libs to /usr/local/lib] [Installing Headers to /usr/local/include/RF24] make: Leaving directory '/home/pi/rf24libs/RF24' Source to test data receiving. Check the transferring site in Rover . rf24_tx.cpp #include <iostream> // cin, cout, endl #include <RF24/RF24.h> // create RF24 instance RF24 radio ( 24 /* CE = sys_gpio_24 */ , 0 /* CSN = 0 means spidev0.0 */ /* default speed is 10 Mbps */ ); // max payload of RF24 is 32 bytes uint8_t payload [ 32 ]; int main ( int argc , char ** argv ) { // perform hardware check if ( ! radio . begin ()) { std :: cout << \"radio hardware is not responding!!\" << std :: endl ; return 0 ; // quit now } radio . setPayloadSize ( 32 ); radio . setChannel ( 100 ); // 2400 + 100 = 2500 MHz, out of WiFi band // address, defaut length is 5 uint8_t tx_address [ 6 ] = \"1Addr\" ; // write to radio . openWritingPipe ( tx_address ); // always uses pipe 0 // For debugging info radio . printDetails (); // (smaller) function that prints raw register values radio . printPrettyDetails (); // (larger) function that prints human readable data // Start std :: cout << \"Start TX\" << std :: endl ; radio . stopListening (); // put radio in TX mode while ( true ) { radio . write ( & payload , 32 ); // transmit } } Compile the source code: arm-linux-gnueabihf-g++ -marm -march = armv6zk -mtune = arm1176jzf-s -mfpu = vfp -mfloat-abi = hard -Ofast -Wall -pthread rf24_tx.cpp -lrf24 -o rf24_tx or just use: g++ -Ofast -Wall -pthread rf24_tx.cpp -lrf24 -o rf24_tx Run it and see the log: ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO24 SPI Speedz = 10 Mhz ================ NRF Configuration ================ STATUS = 0x0e RX_DR=0 TX_DS=0 MAX_RT=0 RX_P_NO=7 TX_FULL=0 RX_ADDR_P0-1 = 0x7264644131 0x65646f4e31 RX_ADDR_P2-5 = 0xc3 0xc4 0xc5 0xc6 TX_ADDR = 0x7264644131 RX_PW_P0-6 = 0x20 0x20 0x20 0x20 0x20 0x20 EN_AA = 0x3f EN_RXADDR = 0x03 RF_CH = 0x64 RF_SETUP = 0x03 CONFIG = 0x0e DYNPD/FEATURE = 0x00 0x00 Data Rate = 1 MBPS Model = nRF24L01+ CRC Length = 16 bits PA Power = PA_LOW ARC = 0 ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO24 SPI Frequency = 10 Mhz ================ NRF Configuration ================ Channel = 100 (~ 2500 MHz) RF Data Rate = 1 MBPS RF Power Amplifier = PA_LOW RF Low Noise Amplifier = Enabled CRC Length = 16 bits Address Length = 5 bytes Static Payload Length = 32 bytes Auto Retry Delay = 1500 microseconds Auto Retry Attempts = 15 maximum Packets lost on current channel = 0 Retry attempts made for last transmission = 0 Multicast = Disabled Custom ACK Payload = Disabled Dynamic Payloads = Disabled Auto Acknowledgment = Enabled Primary Mode = TX TX address = 0x7264644131 pipe 0 ( open ) bound = 0x7264644131 pipe 1 ( open ) bound = 0x65646f4e31 pipe 2 (closed) bound = 0xc3 pipe 3 (closed) bound = 0xc4 pipe 4 (closed) bound = 0xc5 pipe 5 (closed) bound = 0xc6 Start TX 6. OLED driver \u2693\ufe0e Download source code and build: git clone https://github.com/vuquangtrong/OLED_SSD1306_I2C_Linux.git && \\ cd OLED_SSD1306_I2C_Linux && \\ make && \\ sudo make install Write a simple app to a progress bar with label and numeric value: progress_bar.c #include <string.h> #include <unistd.h> #include <SSD1306/ssd1306.h> int main () { char counter = 0 ; char buffer [ 3 ]; SSD1306_Init ( \"/dev/i2c-1\" ); while ( 1 ) { sprintf ( buffer , \"%d\" , counter ++ ); SSD1306_Clear (); SSD1306_WriteString ( 0 , 0 , \"counter:\" , & Font_7x10 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_WriteString ( 0 , 10 , buffer , & Font_11x18 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_DrawRectangle ( 0 , 28 , 128 , 4 , SSD1306_WHITE ); SSD1306_DrawFilledRectangle ( 0 , 28 , counter * 128 / 256 , 4 , SSD1306_WHITE ); SSD1306_Screen_Update (); sleep ( 0.2 ); } return 0 ; } Compile and run: gcc progress_bar.c -lssd1306 -o progress_bar && \\ ./progress_bar 7. Auto-mount USB \u2693\ufe0e Check out and install: git clone https://github.com/vuquangtrong/USB_Automount.git cd USB_Automount ./install Plugged-in USB will be mounted into /media/<Label> or /media/<sdXy> . 8. Auto-start application \u2693\ufe0e Refer to Rover setup .","title":"Base station"},{"location":"base/#1-operating-system","text":"Download Raspberry Pi Imager and install it. Run the Pi Imager, and select the Desktop version but without recommended software. Press Ctrl + Shift + X to show the advanced menu, fill some settings as below: Hostname: base SSH: yes and set a password WiFi: yes and set a SSID and its password Note to save the options for later use if needed. Alternative method using balenaEtcher Download Raspberry Pi OS image, select Desktop version but without recommended software. Download balenaEtcher and install it, and write the Image in an SD Card. After finishing, re-plug the SD Card. Add an empty file with name ssh into the boot partition to enabled SSH. It is also recommended enabling WiFi network by add a file wpa_supplicant.conf in the boot partition: wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } For the official Raspberry Pi OS, the default username is pi , with password raspberry , on the host raspberrypi . Bonjour is a service from Apple to discovery devices in a network using hostname. Install it and then Pi can be connected using its default hostname raspberrypi.local . SSH Connection With SSH enabled and WiFi network connected, accessing to Raspberry Pi is remotely through SSH. Using any X11-fordwarding SSH, such as MobaXterm, GUI application can be shown in the host PC. Some tweaks can be applied after login: To use some list command, in .bashrc , enable alias for ls command. To disable animation on GUI: gsettings set org.gnome.desktop.interface enable-animations false If eth0 is used, it may take priority of network connection over the wlan0 . If internet is accessible through wlan0 , edit /etc/dhcpcd.conf and add this: interface wlan0 metric 100 Then wireless will have precedence, its default route/gateway will be used. The official tool raspi-config should be used to configure the GPIO on Pi. sudo raspi-config Select Interfacing Options and select below item: SPI > Enable SPI I2C > Enable I2C Arm Serial Port > No login shell > Enable UART After enabling the primary UART, the VPU clock will be set at 250 MHz. Run groups to see the current user is added into groups for using GPIO including gpio , i2c and spi . Raspberry Pi 40-pin header","title":"1. Operating System"},{"location":"base/#2-uart-config","text":"Refer to Raspberry Pi UART . There are two types of UART available on the Raspberry Pi - PL011 and mini UART . The PL011 is a capable, broadly 16550-compatible UART, while the mini UART has a reduced feature set. All UARTs on the Raspberry Pi are 3.3V only. The Raspberry Pi 3 has below default UART configuration: Hardware port Type Usage Pin Map Linux Device UART0 PL011 Secondary (Bluetooth), enabled N/A /dev/serial1 UART1 mini UART Primary, disabled GPIO 14 (TX), GPIO 15 (RX) /dev/serial0 That means the exported UART port on GPIO header is a Mini-UART. The problem is the speed of mini-UART port depends on VPU (graphic) Core Frequency. The primary UART is disabled by default. It has to be enabled by running raspi-config to set up interfaces. To get rid of using sudo permission, add current user into the serial group. Run ls -al /dev/tty* to check the user group of ttyS0 , ttyTHS1 . Normally, it is needed to add current user into tty and dialout groups: sudo usermod -a -G tty $USER sudo usermod -a -G dialout $USER sudo reboot UART Testing For testing, a serial terminal must be installed. Choose one of below. putty sudo apt install putty -y putty Follow GUI to run. minicom sudo apt install minicom -y minicom -D /dev/ttyS0 -b 115200 Press Ctrl-A X to exit. picocom sudo apt install picocom -y picocom /dev/ttyS0 -b 115200 Press Ctrl-A and Ctrl-X to exit. screen sudo apt install screen -y screen /dev/ttyS0 115200 Press Ctrl-A K to exit.","title":"2. UART Config"},{"location":"base/#3-module-connection","text":"Refer to below pinout diagram: Base wiring","title":"3. Module Connection"},{"location":"base/#4-serial-driver","text":"Download source code and build: git clone https://github.com/vuquangtrong/SerialPort.git && \\ cd SerialPort && \\ make && \\ sudo make install An example to communicate with Serial port: // Serial library #include \"serial/SerialPort.h\" #include <unistd.h> #include <stdio.h> #define SERIAL_PORT \"/dev/ttyS0\" int main ( /*int argc, char *argv[]*/ ) { SerialPort serial ; char errorOpening = serial . openDevice ( SERIAL_PORT , 115200 ); if ( errorOpening != 1 ) return errorOpening ; printf ( \"Successful connection to %s \\n \" , SERIAL_PORT ); // Display ASCII characters (from 32 to 128) for ( int c = 32 ; c < 128 ; c ++ ) { serial . writeChar ( c ); usleep ( 10000 ); } // Read lines and print them out char line [ 1024 ]; while ( 1 ) { int n = serial . readBytes ( line , sizeof ( line )); if ( n >= 0 ) { std :: cout << std :: string ( line , n ) << std :: endl ; } } // Close the serial device serial . closeDevice (); return 0 ; } Compile and run: g++ example.cpp -lserial -o example","title":"4. Serial driver"},{"location":"base/#5-nrf24-driver","text":"Download source code from GitHub and build: git clone https://github.com/vuquangtrong/RF24 && \\ cd RF24 && \\ ./configure --driver = SPIDEV && \\ make && \\ sudo make install SPIDEV must be used to avoid permission error when using default RPi BCM driver Work with the original source code GitHub at https://github.com/nRF24/RF24 . The guide to install in Linux at https://nrf24.github.io/RF24/md_docs_linux_install.html . Download the install.sh file: wget http://tmrh20.github.io/RF24Installer/RPi/install.sh Make it executable: chmod +x install.sh Run it and choose the option: RF24 Core SPIDEV driver ./install.sh Do you want to install GIT using APT (Used to download source code) [y/N]? n Do you want to install the RF24 core library, [y/N]? y Do you want to install the RF24Network library [y/N]? Do you want to install the RF24Mesh library [y/N]? Do you want to install the RF24Gateway library [y/N]? Installing RF24 Repo... *** Install RF24 core using? *** 1.BCM2835 Driver(Performance) 2.SPIDEV(Compatibility, Default) 3.WiringPi(Its WiringPi!) 4.MRAA(Intel Devices) 5.LittleWire 2 ... [Installing Libs to /usr/local/lib] [Installing Headers to /usr/local/include/RF24] make: Leaving directory '/home/pi/rf24libs/RF24' Source to test data receiving. Check the transferring site in Rover . rf24_tx.cpp #include <iostream> // cin, cout, endl #include <RF24/RF24.h> // create RF24 instance RF24 radio ( 24 /* CE = sys_gpio_24 */ , 0 /* CSN = 0 means spidev0.0 */ /* default speed is 10 Mbps */ ); // max payload of RF24 is 32 bytes uint8_t payload [ 32 ]; int main ( int argc , char ** argv ) { // perform hardware check if ( ! radio . begin ()) { std :: cout << \"radio hardware is not responding!!\" << std :: endl ; return 0 ; // quit now } radio . setPayloadSize ( 32 ); radio . setChannel ( 100 ); // 2400 + 100 = 2500 MHz, out of WiFi band // address, defaut length is 5 uint8_t tx_address [ 6 ] = \"1Addr\" ; // write to radio . openWritingPipe ( tx_address ); // always uses pipe 0 // For debugging info radio . printDetails (); // (smaller) function that prints raw register values radio . printPrettyDetails (); // (larger) function that prints human readable data // Start std :: cout << \"Start TX\" << std :: endl ; radio . stopListening (); // put radio in TX mode while ( true ) { radio . write ( & payload , 32 ); // transmit } } Compile the source code: arm-linux-gnueabihf-g++ -marm -march = armv6zk -mtune = arm1176jzf-s -mfpu = vfp -mfloat-abi = hard -Ofast -Wall -pthread rf24_tx.cpp -lrf24 -o rf24_tx or just use: g++ -Ofast -Wall -pthread rf24_tx.cpp -lrf24 -o rf24_tx Run it and see the log: ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO24 SPI Speedz = 10 Mhz ================ NRF Configuration ================ STATUS = 0x0e RX_DR=0 TX_DS=0 MAX_RT=0 RX_P_NO=7 TX_FULL=0 RX_ADDR_P0-1 = 0x7264644131 0x65646f4e31 RX_ADDR_P2-5 = 0xc3 0xc4 0xc5 0xc6 TX_ADDR = 0x7264644131 RX_PW_P0-6 = 0x20 0x20 0x20 0x20 0x20 0x20 EN_AA = 0x3f EN_RXADDR = 0x03 RF_CH = 0x64 RF_SETUP = 0x03 CONFIG = 0x0e DYNPD/FEATURE = 0x00 0x00 Data Rate = 1 MBPS Model = nRF24L01+ CRC Length = 16 bits PA Power = PA_LOW ARC = 0 ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO24 SPI Frequency = 10 Mhz ================ NRF Configuration ================ Channel = 100 (~ 2500 MHz) RF Data Rate = 1 MBPS RF Power Amplifier = PA_LOW RF Low Noise Amplifier = Enabled CRC Length = 16 bits Address Length = 5 bytes Static Payload Length = 32 bytes Auto Retry Delay = 1500 microseconds Auto Retry Attempts = 15 maximum Packets lost on current channel = 0 Retry attempts made for last transmission = 0 Multicast = Disabled Custom ACK Payload = Disabled Dynamic Payloads = Disabled Auto Acknowledgment = Enabled Primary Mode = TX TX address = 0x7264644131 pipe 0 ( open ) bound = 0x7264644131 pipe 1 ( open ) bound = 0x65646f4e31 pipe 2 (closed) bound = 0xc3 pipe 3 (closed) bound = 0xc4 pipe 4 (closed) bound = 0xc5 pipe 5 (closed) bound = 0xc6 Start TX","title":"5. nRF24 driver"},{"location":"base/#6-oled-driver","text":"Download source code and build: git clone https://github.com/vuquangtrong/OLED_SSD1306_I2C_Linux.git && \\ cd OLED_SSD1306_I2C_Linux && \\ make && \\ sudo make install Write a simple app to a progress bar with label and numeric value: progress_bar.c #include <string.h> #include <unistd.h> #include <SSD1306/ssd1306.h> int main () { char counter = 0 ; char buffer [ 3 ]; SSD1306_Init ( \"/dev/i2c-1\" ); while ( 1 ) { sprintf ( buffer , \"%d\" , counter ++ ); SSD1306_Clear (); SSD1306_WriteString ( 0 , 0 , \"counter:\" , & Font_7x10 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_WriteString ( 0 , 10 , buffer , & Font_11x18 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_DrawRectangle ( 0 , 28 , 128 , 4 , SSD1306_WHITE ); SSD1306_DrawFilledRectangle ( 0 , 28 , counter * 128 / 256 , 4 , SSD1306_WHITE ); SSD1306_Screen_Update (); sleep ( 0.2 ); } return 0 ; } Compile and run: gcc progress_bar.c -lssd1306 -o progress_bar && \\ ./progress_bar","title":"6. OLED driver"},{"location":"base/#7-auto-mount-usb","text":"Check out and install: git clone https://github.com/vuquangtrong/USB_Automount.git cd USB_Automount ./install Plugged-in USB will be mounted into /media/<Label> or /media/<sdXy> .","title":"7. Auto-mount USB"},{"location":"base/#8-auto-start-application","text":"Refer to Rover setup .","title":"8. Auto-start application"},{"location":"components/","text":".md-typeset .admonition.specs, .md-typeset details.specs { margin: -2rem 0 0 -1.2rem; } .md-typeset .admonition.specs > .admonition-title::before, .md-typeset details.specs > summary::before{ visibility: hidden; } The system has 2 main parts: Rover is mounted on an RC Car or Drone to scan an area and map the captured point-cloud. Base acts as a stationary point which provide positioning correction to Rover for better accuracy. var expanded = false; function toggleDetails() { expanded = !expanded; self.checked = expanded; var d = document.getElementsByTagName(\"details\"); Array.from(d).forEach( function(obj, idx) { obj.open = expanded; }); var i = document.querySelectorAll(\"input.specs\"); console.log(i) Array.from(i).forEach( function(obj, idx) { obj.checked = expanded; }); } Rover \u2693\ufe0e Show specification Livox Lidar Mid-40 100,000 points per second POV: 38.4\u00b0 circular Upto 260m @ 80% reflectivity Livox Converter 1.0 : Power, Ethernet, Sync RS485. > It's better to get Converter 2.0 Jetson Nano Developer Kit CPU Quad-core ARM A57 @ 1.43 GHz GPU 128-core Maxwell RAM 4 GB 64-bit LPDDR4 25.6 GB/s Gigabit Ethernet, M.2 Key E 4x USB 3.0, USB 2.0 Micro-B GPIO, I2C, I2S, SPI, UARTs MicroSD Card Should have at least 32 GB at high speed (V30) for saving point louds Sandisk Ultra 16 GB, class 10, SDHC I Unicorecomm GNSS UB482 GPS L1/L2 + BDS B1/B2 + GLONASS L1/ L2 + Galileo E1/E5b + QZSS L1/L2 Two antennas, support heading 20 Hz data output rate Ethernet, serial port, SPI, 1PPS Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MMCX Male UB482 has MMCX (Mini-MCX) Female connector HX-CH7604A has SMA Male connector InvenSense DK-20789 7-axis motion sensor Embedded Microchip G55 MCU and debugger Embedded Motion Drivers Rechargeable Battery 16V with 2000 mAh Peak current at 4 A DC-DC Converter Except Lidar, all other boards use 5V Peak current at 4 A USB WiFi dongle TP-Link WN725N 150Mbps 802.11b/g/n, Internal antenna Ad-Hoc / Infrastructure Mode WiFi router No need this component if using a USB WiFi dongle connected to the Jetson board, and Lidar is connected directly with it. 4-port LAN 2 x Ethernet Cable Either connect Lidar to the Router or connect to the Jetson board directly after setting up static IPs on both sides nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to RS485 No need this component if using Livox Converter 2.0 5V operation, differential voltage >= 200 mV 3x USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface Base \u2693\ufe0e Show specification Raspberry Pi 3 B+ This can be repalaced by a MCU as Base only needs to log data and transmit RTCM3 messages Broadcom BCM2837B0, Cortex-A53 (ARMv8) 64-bit SoC @ 1.4GHz 1GB LPDDR2 SDRAM 2.4GHz and 5GHz IEEE 802.11.b/g/n/ac wireless LAN, Bluetooth 4.2, BLE Gigabit Ethernet over USB 2.0 4 USB 2.0 ports GPIO, I2C, I2S, SPI, UARTs Unicorecomm GNSS UB4B0M Should cover the same constellation system of the Rover GPS L1/L2/L5 + BDS B1/B2/B3 + GLONASS L1/L2 + Galileo E1/E5a/E5b+ QZSS L1/L2/L5 UARTs, 1PPS Onboard MEMS integrated navigation ?? Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MCX Male UB4B0M has MCX Female connector HX-CH7604A has SMA Male connector MicroSD Card Sandisk Ultra 16 GB, class 10, SDHC I Rechargeable Battery 5V with 2000 mAh Peak current at 2 A nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface Other stuff \u2693\ufe0e Show specification STM32 Dev board Emulate GNSS data when GPS is not available (in house, or cloudy days) Header 2.0 mm, 2.54 mm Unicorecomm GNSS modules use headers at 2.0 mm pitch Jetson and Pi modules use headers at 2.54 mm pitch PCB boards, M2.5 and M3 Copper Cylinder, Bolts Remote Control Car with large base Mount Rover on the car for testing","title":"Components"},{"location":"components/#rover","text":"Show specification Livox Lidar Mid-40 100,000 points per second POV: 38.4\u00b0 circular Upto 260m @ 80% reflectivity Livox Converter 1.0 : Power, Ethernet, Sync RS485. > It's better to get Converter 2.0 Jetson Nano Developer Kit CPU Quad-core ARM A57 @ 1.43 GHz GPU 128-core Maxwell RAM 4 GB 64-bit LPDDR4 25.6 GB/s Gigabit Ethernet, M.2 Key E 4x USB 3.0, USB 2.0 Micro-B GPIO, I2C, I2S, SPI, UARTs MicroSD Card Should have at least 32 GB at high speed (V30) for saving point louds Sandisk Ultra 16 GB, class 10, SDHC I Unicorecomm GNSS UB482 GPS L1/L2 + BDS B1/B2 + GLONASS L1/ L2 + Galileo E1/E5b + QZSS L1/L2 Two antennas, support heading 20 Hz data output rate Ethernet, serial port, SPI, 1PPS Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MMCX Male UB482 has MMCX (Mini-MCX) Female connector HX-CH7604A has SMA Male connector InvenSense DK-20789 7-axis motion sensor Embedded Microchip G55 MCU and debugger Embedded Motion Drivers Rechargeable Battery 16V with 2000 mAh Peak current at 4 A DC-DC Converter Except Lidar, all other boards use 5V Peak current at 4 A USB WiFi dongle TP-Link WN725N 150Mbps 802.11b/g/n, Internal antenna Ad-Hoc / Infrastructure Mode WiFi router No need this component if using a USB WiFi dongle connected to the Jetson board, and Lidar is connected directly with it. 4-port LAN 2 x Ethernet Cable Either connect Lidar to the Router or connect to the Jetson board directly after setting up static IPs on both sides nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to RS485 No need this component if using Livox Converter 2.0 5V operation, differential voltage >= 200 mV 3x USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface","title":"Rover"},{"location":"components/#base","text":"Show specification Raspberry Pi 3 B+ This can be repalaced by a MCU as Base only needs to log data and transmit RTCM3 messages Broadcom BCM2837B0, Cortex-A53 (ARMv8) 64-bit SoC @ 1.4GHz 1GB LPDDR2 SDRAM 2.4GHz and 5GHz IEEE 802.11.b/g/n/ac wireless LAN, Bluetooth 4.2, BLE Gigabit Ethernet over USB 2.0 4 USB 2.0 ports GPIO, I2C, I2S, SPI, UARTs Unicorecomm GNSS UB4B0M Should cover the same constellation system of the Rover GPS L1/L2/L5 + BDS B1/B2/B3 + GLONASS L1/L2 + Galileo E1/E5a/E5b+ QZSS L1/L2/L5 UARTs, 1PPS Onboard MEMS integrated navigation ?? Harxon HX-CH7604A antennas All-constellation Multi-frequency L1/L2, G1/G2, E1, B1/B2/B3 SMA Female to MCX Male UB4B0M has MCX Female connector HX-CH7604A has SMA Male connector MicroSD Card Sandisk Ultra 16 GB, class 10, SDHC I Rechargeable Battery 5V with 2000 mAh Peak current at 2 A nRF24L01 2.4GHz Transceiver + PA + LNA ISM 2.4GHz, 126 Channels GFSK 250kbps, 1Mbps v\u00e0 2Mbps SPI interface to host MCU PA + LNA for upto 1 Km range USB TTL to COM No need this component if using on-board UARTs port after reconfiguring OS kernel 3.3V/ 5V to USB COM OLED LCD Show system status without connecting to PC via WiFi 128x64 Monochrome I2C interface","title":"Base"},{"location":"components/#other-stuff","text":"Show specification STM32 Dev board Emulate GNSS data when GPS is not available (in house, or cloudy days) Header 2.0 mm, 2.54 mm Unicorecomm GNSS modules use headers at 2.0 mm pitch Jetson and Pi modules use headers at 2.54 mm pitch PCB boards, M2.5 and M3 Copper Cylinder, Bolts Remote Control Car with large base Mount Rover on the car for testing","title":"Other stuff"},{"location":"design/","text":"Based on study of a reference project from Livox. 1. Hardware \u2693\ufe0e Refer to the list of Components . 1.1. Block diagram \u2693\ufe0e Rover's components Base's components Notes : All modules, except Livox's, are 3.3 V level, so they are can be connected directly. This helps to omit USB TTL-to-COM. Raspberry Pi 3 B+ has an on-board WiFi module. 1.2. Power supply \u2693\ufe0e Rover's power supply Base's power supply Notes : The input voltage of Livox Converter is 10 ~ 16 VDC, therefore, an 1N5400 diode can be connected in serial to reduce voltage to under 16 VDC. 2. Wiring \u2693\ufe0e Rover wiring Base wiring UART RX/TX problem Here is some reports showing that Jetson boards have problems on UART RX/TX pin when connecting that port directly to an other board. It maily causes by the capitive loading on the pin, if the loop-back test does not have any problem. If that problem happens, please add a 10K pull-down resister on RX/TX pin. Refer to Unreliable serial communcation via the UART TX/RX GPIO Pins . 3. Software \u2693\ufe0e The mapping node gets the pointcloud from the Lidar ROS driver node, the GNSS and IMU data from the APX-15 node and processes them together: Store pointcloud with timestamp Store GNSS with timestamp Store IMU with timestamp Align packets using timestamp Apply IMU to GNSS point, and stick geographical information to pointcloud Combine position and pose into pointcloud","title":"System design"},{"location":"design/#1-hardware","text":"Refer to the list of Components .","title":"1. Hardware"},{"location":"design/#11-block-diagram","text":"Rover's components Base's components Notes : All modules, except Livox's, are 3.3 V level, so they are can be connected directly. This helps to omit USB TTL-to-COM. Raspberry Pi 3 B+ has an on-board WiFi module.","title":"1.1. Block diagram"},{"location":"design/#12-power-supply","text":"Rover's power supply Base's power supply Notes : The input voltage of Livox Converter is 10 ~ 16 VDC, therefore, an 1N5400 diode can be connected in serial to reduce voltage to under 16 VDC.","title":"1.2. Power supply"},{"location":"design/#2-wiring","text":"Rover wiring Base wiring UART RX/TX problem Here is some reports showing that Jetson boards have problems on UART RX/TX pin when connecting that port directly to an other board. It maily causes by the capitive loading on the pin, if the loop-back test does not have any problem. If that problem happens, please add a 10K pull-down resister on RX/TX pin. Refer to Unreliable serial communcation via the UART TX/RX GPIO Pins .","title":"2. Wiring"},{"location":"design/#3-software","text":"The mapping node gets the pointcloud from the Lidar ROS driver node, the GNSS and IMU data from the APX-15 node and processes them together: Store pointcloud with timestamp Store GNSS with timestamp Store IMU with timestamp Align packets using timestamp Apply IMU to GNSS point, and stick geographical information to pointcloud Combine position and pose into pointcloud","title":"3. Software"},{"location":"gnss/","text":"","title":"GNSS"},{"location":"gnss-emulator/","text":"1. Requirements \u2693\ufe0e The emulator should output: PPS signal at 1 Hz, 25% duty cycle GPRMC at 1 Hz, about 83 bytes per message GNGGA at 1 Hz, about 86 bytes per message OBSVMA at 1 Hz, about 2700 bytes per message All messages are aligned to the rising edge of PPS signal 2. Configuration \u2693\ufe0e The main MCU is STM32F103C8Tx , mounted on a Blue Pill dev board. 2.1. System Clock \u2693\ufe0e Use an external 8 MHz crystal to make 72 MHz system clock. 2.2. PPS Signal \u2693\ufe0e PPS signal will be output by PWM function of the Timer 1 module: Clock source: Internal Clock, at 72 MHz Channel 1: PWM Generation CH1 Prescaler PSC : 36000-1 Counter Period AAR : 2000-1 PWM Generation Channel 1: Mode: 1 (Positive at start) Pulse: 500 (25% of AAR) Interrupt: on Update 2.3. UART Protocol \u2693\ufe0e Using a setting of 8-N-1 (8 bit, No parity, 1 stop bit), each byte requires 10 bits. Baud rate at 115200 bit-per-second means the speed is 11520 byte-per-second. At this speed, 4 OBSVMA messages can be transfer completely in a second. All messages on UART ports will be sent in DMA mode which allows sending data concurrently. Interrupt must be enabled to make DMA function work properly. The UART1, UART2, UART3 are configured as: Mode: Asynchronous Hardware Flow Control: Disabled Baud Rate: 115200 bps, 8-N-1 Interrupt: Enabled DMA: Channel: TX Direction: Memory to Peripheral , Mode: Normal Data width: Byte Increment Address: Memory only 2.4. Messages \u2693\ufe0e All messages are pre-filled, only some necessary parts will be modified to reduce processing time. UTC Time must be updated every second in GPRMC and GNGGA GPRMC message must have correct CRC value Example message : $GPRMC , 000000.00 , A , 2057.59811106 , N , 10546.17288672 , E , 0.109 , 193.8 , 200821 , 1.5 , W , A * 21 $GNGGA , 000000.00 , 2057.59811106 , N , 10546.17288672 , E , 1 , 18 , 2.2 , 16.5017 , M , -28.2478 , M ,, * 61 #OBSVMA,92,GPS,FINE,2172,171764000,0,0,18,4;36,0,6,21338531.558,-112134733.414741,4,50,1574.771,4911,0,120.007,08181c24,0,6,21338529.258,-87377704.069472,6,62,1227.131,4548,0,124.007,05381c2b,0,14,20319924.197,-106781918.629190,7,69,493.942,4417,0,120.007,08181c44,0,14,20319920.803,-83206684.730617,17,147,384.872,3805,0,120.007,01301c4b,0,17,21945245.330,-115323032.576040,7,72,257.824,4358,0,120.007,08181c64,0,17,21945240.311,-89862089.990482,16,133,200.906,3462,0,124.007,05381c6b,0,28,20944473.540,-110063951.781589,13,108,1803.692,3715,0,120.007,08181c84,0,28,20944484.235,-85764160.734407,109,1499,1405.503,2691,0,0.000,0130108b,0,30,22761674.739,-119613418.379433,15,129,-2607.156,3502,0,120.007,08181ca4,0,34,36431345.429,-191447981.578579,17,145,723.997,3348,0,61.020,08181de4,0,34,36431346.104,-149180346.656281,25,213,564.374,3018,0,64.000,05381deb,0,51,20101165.397,-107150539.530252,9,84,2120.845,4104,0,98.020,08191c24,0,51,20101162.656,-83339293.141160,15,128,1649.603,3515,0,98.020,00b91c2b,9,61,20777773.795,-111108092.002339,8,76,-1034.863,4278,0,98.020,08191cc4,9,61,20777767.903,-86417385.183432,8,76,-804.847,4262,0,98.020,00b91ccb,5,50,19929653.269,-106423234.539838,13,113,-2263.388,3668,0,97.000,08191ce4,5,50,19929648.776,-82773623.659687,12,101,-1760.391,3782,0,99.000,00b91ceb,0,2,36696586.693,-191088755.879035,6,67,237.164,4442,0,124.007,0c1c1c24,0,2,36696569.181,-147761876.696199,10,87,183.488,4043,0,124.007,063c1c2b,0,3,36400030.347,-189544510.384493,4,54,258.795,4714,0,124.007,0c1c1c44,0,3,36400015.890,-146567780.955546,7,73,199.972,4327,0,124.007,063c1c4b,0,7,35994436.346,-187432473.995137,9,84,598.363,4120,0,124.007,081c1c64,0,7,35994419.240,-144934613.705130,12,107,462.734,3724,0,124.007,023c1c6b,0,8,36373710.476,-189407461.691094,6,67,40.827,4441,0,124.007,081c1c84,0,8,36373693.708,-146461793.687978,9,81,31.530,4163,0,124.007,023c1c8b,0,10,36089453.781,-187927246.296557,11,94,817.209,3920,0,124.007,081c1ca4,0,10,36089437.896,-145317213.651417,13,112,632.177,3675,0,124.007,023c1cab,0,13,36416396.770,-189629741.119410,6,67,547.278,4446,0,124.007,081c1cc4,0,13,36416388.298,-146633708.070459,11,94,423.233,3903,0,124.007,023c1ccb,0,30,22898967.933,-119240944.705313,17,143,339.060,3368,0,124.987,081c1ce4,0,56,42284061.567,-220184200.279297,6,65,527.536,4481,0,118.007,081c1d04,0,38,35881839.606,-186846150.560976,4,51,183.397,4775,0,118.007,081c1d24,0,25,23468075.990,-123325572.189710,4,50,49.187,4832,0,119.007,085b1c44,0,25,23468072.270,-94496203.038075,7,73,37.687,4331,0,119.007,02331c40,0,36,23920511.872,-125703139.336542,6,66,-175.856,4472,0,100.987,085b1d44,0,36,23920511.685,-96317987.477716,9,84,-134.684,4112,0,101.007,02331d40*a302f998 Pin map on STM32F103C8Tx 3. Implementation \u2693\ufe0e Checkout GitHub repo: https://github.com/vuquangtrong/lidar-mapping-poc.gnss_emu.git . Result : Output of GNSS emulator Concurrent outputs","title":"GNSS emulator"},{"location":"gnss-emulator/#1-requirements","text":"The emulator should output: PPS signal at 1 Hz, 25% duty cycle GPRMC at 1 Hz, about 83 bytes per message GNGGA at 1 Hz, about 86 bytes per message OBSVMA at 1 Hz, about 2700 bytes per message All messages are aligned to the rising edge of PPS signal","title":"1. Requirements"},{"location":"gnss-emulator/#2-configuration","text":"The main MCU is STM32F103C8Tx , mounted on a Blue Pill dev board.","title":"2. Configuration"},{"location":"gnss-emulator/#21-system-clock","text":"Use an external 8 MHz crystal to make 72 MHz system clock.","title":"2.1. System Clock"},{"location":"gnss-emulator/#22-pps-signal","text":"PPS signal will be output by PWM function of the Timer 1 module: Clock source: Internal Clock, at 72 MHz Channel 1: PWM Generation CH1 Prescaler PSC : 36000-1 Counter Period AAR : 2000-1 PWM Generation Channel 1: Mode: 1 (Positive at start) Pulse: 500 (25% of AAR) Interrupt: on Update","title":"2.2. PPS Signal"},{"location":"gnss-emulator/#23-uart-protocol","text":"Using a setting of 8-N-1 (8 bit, No parity, 1 stop bit), each byte requires 10 bits. Baud rate at 115200 bit-per-second means the speed is 11520 byte-per-second. At this speed, 4 OBSVMA messages can be transfer completely in a second. All messages on UART ports will be sent in DMA mode which allows sending data concurrently. Interrupt must be enabled to make DMA function work properly. The UART1, UART2, UART3 are configured as: Mode: Asynchronous Hardware Flow Control: Disabled Baud Rate: 115200 bps, 8-N-1 Interrupt: Enabled DMA: Channel: TX Direction: Memory to Peripheral , Mode: Normal Data width: Byte Increment Address: Memory only","title":"2.3. UART Protocol"},{"location":"gnss-emulator/#24-messages","text":"All messages are pre-filled, only some necessary parts will be modified to reduce processing time. UTC Time must be updated every second in GPRMC and GNGGA GPRMC message must have correct CRC value Example message : $GPRMC , 000000.00 , A , 2057.59811106 , N , 10546.17288672 , E , 0.109 , 193.8 , 200821 , 1.5 , W , A * 21 $GNGGA , 000000.00 , 2057.59811106 , N , 10546.17288672 , E , 1 , 18 , 2.2 , 16.5017 , M , -28.2478 , M ,, * 61 #OBSVMA,92,GPS,FINE,2172,171764000,0,0,18,4;36,0,6,21338531.558,-112134733.414741,4,50,1574.771,4911,0,120.007,08181c24,0,6,21338529.258,-87377704.069472,6,62,1227.131,4548,0,124.007,05381c2b,0,14,20319924.197,-106781918.629190,7,69,493.942,4417,0,120.007,08181c44,0,14,20319920.803,-83206684.730617,17,147,384.872,3805,0,120.007,01301c4b,0,17,21945245.330,-115323032.576040,7,72,257.824,4358,0,120.007,08181c64,0,17,21945240.311,-89862089.990482,16,133,200.906,3462,0,124.007,05381c6b,0,28,20944473.540,-110063951.781589,13,108,1803.692,3715,0,120.007,08181c84,0,28,20944484.235,-85764160.734407,109,1499,1405.503,2691,0,0.000,0130108b,0,30,22761674.739,-119613418.379433,15,129,-2607.156,3502,0,120.007,08181ca4,0,34,36431345.429,-191447981.578579,17,145,723.997,3348,0,61.020,08181de4,0,34,36431346.104,-149180346.656281,25,213,564.374,3018,0,64.000,05381deb,0,51,20101165.397,-107150539.530252,9,84,2120.845,4104,0,98.020,08191c24,0,51,20101162.656,-83339293.141160,15,128,1649.603,3515,0,98.020,00b91c2b,9,61,20777773.795,-111108092.002339,8,76,-1034.863,4278,0,98.020,08191cc4,9,61,20777767.903,-86417385.183432,8,76,-804.847,4262,0,98.020,00b91ccb,5,50,19929653.269,-106423234.539838,13,113,-2263.388,3668,0,97.000,08191ce4,5,50,19929648.776,-82773623.659687,12,101,-1760.391,3782,0,99.000,00b91ceb,0,2,36696586.693,-191088755.879035,6,67,237.164,4442,0,124.007,0c1c1c24,0,2,36696569.181,-147761876.696199,10,87,183.488,4043,0,124.007,063c1c2b,0,3,36400030.347,-189544510.384493,4,54,258.795,4714,0,124.007,0c1c1c44,0,3,36400015.890,-146567780.955546,7,73,199.972,4327,0,124.007,063c1c4b,0,7,35994436.346,-187432473.995137,9,84,598.363,4120,0,124.007,081c1c64,0,7,35994419.240,-144934613.705130,12,107,462.734,3724,0,124.007,023c1c6b,0,8,36373710.476,-189407461.691094,6,67,40.827,4441,0,124.007,081c1c84,0,8,36373693.708,-146461793.687978,9,81,31.530,4163,0,124.007,023c1c8b,0,10,36089453.781,-187927246.296557,11,94,817.209,3920,0,124.007,081c1ca4,0,10,36089437.896,-145317213.651417,13,112,632.177,3675,0,124.007,023c1cab,0,13,36416396.770,-189629741.119410,6,67,547.278,4446,0,124.007,081c1cc4,0,13,36416388.298,-146633708.070459,11,94,423.233,3903,0,124.007,023c1ccb,0,30,22898967.933,-119240944.705313,17,143,339.060,3368,0,124.987,081c1ce4,0,56,42284061.567,-220184200.279297,6,65,527.536,4481,0,118.007,081c1d04,0,38,35881839.606,-186846150.560976,4,51,183.397,4775,0,118.007,081c1d24,0,25,23468075.990,-123325572.189710,4,50,49.187,4832,0,119.007,085b1c44,0,25,23468072.270,-94496203.038075,7,73,37.687,4331,0,119.007,02331c40,0,36,23920511.872,-125703139.336542,6,66,-175.856,4472,0,100.987,085b1d44,0,36,23920511.685,-96317987.477716,9,84,-134.684,4112,0,101.007,02331d40*a302f998 Pin map on STM32F103C8Tx","title":"2.4. Messages"},{"location":"gnss-emulator/#3-implementation","text":"Checkout GitHub repo: https://github.com/vuquangtrong/lidar-mapping-poc.gnss_emu.git . Result : Output of GNSS emulator Concurrent outputs","title":"3. Implementation"},{"location":"imu/","text":"1. Example project \u2693\ufe0e 1.1. Documents \u2693\ufe0e Firstly, check the ICM-20789 Datasheet . Have a quick look of different development kits which can be found in SmartMotion Platform Introduction and Training . The SmartMotion Hardware User Guide shows the notes and schematics of development kits. 1.2. Download \u2693\ufe0e Register an account and download Embedded Motion Drivers (eMD) from the Download center . There are 2 versions: Without Digital Motion Processor (DMP), named eMD-SmartMotion_ICM207xx : Motion processing algorithms will be run on the host processor. The host process reads all raw data and the process them. The prebuilt TDK algorithm and math libraries is not open source. It is compiled and provided as library files libAlgoInvn.a and libMLMath.a . With Digital Motion Processor (DMP) enabled, named eMD-SmartMotion-ICM20789-20689-DMP : Motion processing algorithms will be run on sensor itself. The host process reads all processed data when DMP sends an interrupt status. The firmware of the DMP processor is also prebuilt. It's stored in the binary array defined in icm20789_img.dmp3.h . This array will be uploaded to the DMP Processor when the main application runs. The projects which are used on the DK-20789 board are built with Atmel Studio (newly changed to Microchip Studio). Download the Atmel Studio at the Microchip download page for AVR and SAM devices . After download the eMD SmartMotion ICM-20789 DMP project, open the solution file EMD-G55-ICM207*.atsln to start the project. 1.3. Understanding the example projects \u2693\ufe0e The example projects come with some components of InvenSense, such as Dynamic Protocol Adapter (with Data and Transport layers), and prebuilt algorithms. I haven't found any document about InvenSense's Dynamic Protocol. The application initializes all the components, and then finally does a loop to: read bytes from UART to process commands in Dynamic Protocol Adapter poll sensor's data when sensor sends an interrupt call the algorithms to process sensor's data converted processed sensor's data to messages for Dynamic Protocol Adapter to send through UART Dynamic Protocol Adapter is working well with a provided example host's application named sensor_cli . But this program is close-source, and no document of Dynamic Protocol Adapter is found, Dynamic Protocol Adapter layer should be removed in customized projects. Let's quickly review the application code. UART ports are set up in the function configure_console() . The debug port is through the FLEXCOM7 peripheral, at 921600 bps. The main console is through the FLEXCOM0 peripheral at 2000000 bps. The console UART also enables interruption for receiving ready US_IER_RXRDY . Sensors are set up in the function icm207xx_sensor_setup() and the initial configurations are set in icm207xx_sensor_configuration() function. By default, the Accelerator sensor at +/- 4000 mg, the Gyroscope sensor at +/- 2000 dps, and the Temperature sensore are enabled, and the output rate is 50 Hz. The application attaches the console UART to the Dynamic Protocol Adapter with DynProTransportUart_init() and DynProtocol_init() which set callbacks to handle data in and out through the console UART port. The algorithms are then initialized and configured by the algorithms_init() and algorithms_configure_odr() . Note the output data rate of the sensor should be matched with algorithm's. At the boot time, all sensor output types are turned on. The variable enabled_sensor_mask is used as the flags to set which output types are enabled. Here is the list of sensor output types: Raw Accelerator data Raw Gyroscope data Calibrated Accelerator data Calibrated Gyroscope data Uncalibrated Gyroscope data Game Rotation Vector Two tasks commandHandlerTask and blinkerLedTask are initialized, and started in the InvenSense's scheduler (no document about it, though its code, this not an RTOS, because it schedules tasks and run the selected task in the main loop). In the main loop: the scheduler will check the task which will be executed and runs it call to Icm207xx_data_poll() function to read sensor's data when the interrupt flag irq_from_device is set call to sensor_event() to forward sensor's data to the Dynamic Protocol to encode the message and transmit it to the host The call sequence and data-flow should be modified 2. Modify the project \u2693\ufe0e The example project needs to be modified to adapt to new system. The final result is to get IMU data at 200 Hz. Remove Dynamic Protocol module As it does not have official document, this module is hard to implement in the host side. When this module is removed, the board will directly communicate with the host through UART port. Remove InvenSense scheduler The scheduler is not needed anymore. The board will continuously send out IMU data. Removing this to save resource for printing data. Change the output rate in the file algo_eapi.h : #define DEFAULT_ODR_US 5000 // 200 Hz Redirect the processed sensor data The console UART is set to 921600 bps in the file conf_uart_serial.h : #define CONF_UART_BAUDRATE (921600UL) In the function sensor_event() implemented in the file sensor.c , do not transfer data to Dynamic Protocol, add a function to call to print event data: void sensor_event ( const inv_sensor_event_t * event , void * arg ) { ( void ) arg ; event_printer ( event ); } Enable output types // At boot time, all sensors are turned on. algorithms_sensor_control ( 1 ); sensor_control ( 1 ); // Enable types of output enabled_sensor_mask |= ( 1 << SENSOR_ACC ); Print out sensor data In the main file main.c , implement functions to print out sensor data: static void console_printer ( const char * str , va_list ap ) { static char out_str [ 256 ]; /* static to limit stack usage */ const char * ptr = out_str ; vsnprintf ( & out_str [ 0 ], sizeof ( out_str ), str , ap ); while ( * ptr != '\\0' ) { usart_serial_putchar ( CONSOLE_UART , * ptr ); ++ ptr ; } } static void data_printer ( const char * str , ...) { va_list ap ; va_start ( ap , str ); console_printer ( str , ap ); va_end ( ap ); } void event_printer ( const inv_sensor_event_t * event ) { if ( event -> sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER ) { data_printer ( \"ACC_RAW,%d,%d,%d \\r\\n \" , event -> data . raw3d . vect [ 0 ], event -> data . raw3d . vect [ 1 ], event -> data . raw3d . vect [ 2 ] ); } } Repo of the modified project The modifications are tracked in a repo at: https://github.com/vuquangtrong/eMD-SmartMotion_ICM207xx . The output Here is an example of outputting 4 data types from sensor: Calibrated Accelerator Calibrated Gyroscope Game Rotation Vector Linear Acceleration Data types output from ICM-20789 sensor 3. Output raw data \u2693\ufe0e 4. Appendix \u2693\ufe0e Digital Motion Processor The embedded Digital Motion Processor (DMP) offloads computation of motion processing algorithms from the host processor. The DMP acquires data from the accelerometer and gyroscope, processes the data, and the results can be read from the FIFO. The DMP has access to one of the external pins, which can be used for generating interrupts. The purpose of the DMP is to offload both timing requirements and processing power from the host processor. Typically, motion processing algorithms should be run at a high rate, often around 200 Hz to provide accurate results with low latency. This is required even if the application updates at a much lower rate; for example, a low power user interface may update as slowly as 5 Hz, but the motion processing should still run at 200 Hz. The DMP can be used to minimize power, simplify timing, simplify the software architecture, and save valuable MIPS on the host processor for use in applications. DMP operation is possible in low-power gyroscope and low-power accelerometer modes.","title":"IMU"},{"location":"imu/#1-example-project","text":"","title":"1. Example project"},{"location":"imu/#11-documents","text":"Firstly, check the ICM-20789 Datasheet . Have a quick look of different development kits which can be found in SmartMotion Platform Introduction and Training . The SmartMotion Hardware User Guide shows the notes and schematics of development kits.","title":"1.1. Documents"},{"location":"imu/#12-download","text":"Register an account and download Embedded Motion Drivers (eMD) from the Download center . There are 2 versions: Without Digital Motion Processor (DMP), named eMD-SmartMotion_ICM207xx : Motion processing algorithms will be run on the host processor. The host process reads all raw data and the process them. The prebuilt TDK algorithm and math libraries is not open source. It is compiled and provided as library files libAlgoInvn.a and libMLMath.a . With Digital Motion Processor (DMP) enabled, named eMD-SmartMotion-ICM20789-20689-DMP : Motion processing algorithms will be run on sensor itself. The host process reads all processed data when DMP sends an interrupt status. The firmware of the DMP processor is also prebuilt. It's stored in the binary array defined in icm20789_img.dmp3.h . This array will be uploaded to the DMP Processor when the main application runs. The projects which are used on the DK-20789 board are built with Atmel Studio (newly changed to Microchip Studio). Download the Atmel Studio at the Microchip download page for AVR and SAM devices . After download the eMD SmartMotion ICM-20789 DMP project, open the solution file EMD-G55-ICM207*.atsln to start the project.","title":"1.2. Download"},{"location":"imu/#13-understanding-the-example-projects","text":"The example projects come with some components of InvenSense, such as Dynamic Protocol Adapter (with Data and Transport layers), and prebuilt algorithms. I haven't found any document about InvenSense's Dynamic Protocol. The application initializes all the components, and then finally does a loop to: read bytes from UART to process commands in Dynamic Protocol Adapter poll sensor's data when sensor sends an interrupt call the algorithms to process sensor's data converted processed sensor's data to messages for Dynamic Protocol Adapter to send through UART Dynamic Protocol Adapter is working well with a provided example host's application named sensor_cli . But this program is close-source, and no document of Dynamic Protocol Adapter is found, Dynamic Protocol Adapter layer should be removed in customized projects. Let's quickly review the application code. UART ports are set up in the function configure_console() . The debug port is through the FLEXCOM7 peripheral, at 921600 bps. The main console is through the FLEXCOM0 peripheral at 2000000 bps. The console UART also enables interruption for receiving ready US_IER_RXRDY . Sensors are set up in the function icm207xx_sensor_setup() and the initial configurations are set in icm207xx_sensor_configuration() function. By default, the Accelerator sensor at +/- 4000 mg, the Gyroscope sensor at +/- 2000 dps, and the Temperature sensore are enabled, and the output rate is 50 Hz. The application attaches the console UART to the Dynamic Protocol Adapter with DynProTransportUart_init() and DynProtocol_init() which set callbacks to handle data in and out through the console UART port. The algorithms are then initialized and configured by the algorithms_init() and algorithms_configure_odr() . Note the output data rate of the sensor should be matched with algorithm's. At the boot time, all sensor output types are turned on. The variable enabled_sensor_mask is used as the flags to set which output types are enabled. Here is the list of sensor output types: Raw Accelerator data Raw Gyroscope data Calibrated Accelerator data Calibrated Gyroscope data Uncalibrated Gyroscope data Game Rotation Vector Two tasks commandHandlerTask and blinkerLedTask are initialized, and started in the InvenSense's scheduler (no document about it, though its code, this not an RTOS, because it schedules tasks and run the selected task in the main loop). In the main loop: the scheduler will check the task which will be executed and runs it call to Icm207xx_data_poll() function to read sensor's data when the interrupt flag irq_from_device is set call to sensor_event() to forward sensor's data to the Dynamic Protocol to encode the message and transmit it to the host The call sequence and data-flow should be modified","title":"1.3. Understanding the example projects"},{"location":"imu/#2-modify-the-project","text":"The example project needs to be modified to adapt to new system. The final result is to get IMU data at 200 Hz. Remove Dynamic Protocol module As it does not have official document, this module is hard to implement in the host side. When this module is removed, the board will directly communicate with the host through UART port. Remove InvenSense scheduler The scheduler is not needed anymore. The board will continuously send out IMU data. Removing this to save resource for printing data. Change the output rate in the file algo_eapi.h : #define DEFAULT_ODR_US 5000 // 200 Hz Redirect the processed sensor data The console UART is set to 921600 bps in the file conf_uart_serial.h : #define CONF_UART_BAUDRATE (921600UL) In the function sensor_event() implemented in the file sensor.c , do not transfer data to Dynamic Protocol, add a function to call to print event data: void sensor_event ( const inv_sensor_event_t * event , void * arg ) { ( void ) arg ; event_printer ( event ); } Enable output types // At boot time, all sensors are turned on. algorithms_sensor_control ( 1 ); sensor_control ( 1 ); // Enable types of output enabled_sensor_mask |= ( 1 << SENSOR_ACC ); Print out sensor data In the main file main.c , implement functions to print out sensor data: static void console_printer ( const char * str , va_list ap ) { static char out_str [ 256 ]; /* static to limit stack usage */ const char * ptr = out_str ; vsnprintf ( & out_str [ 0 ], sizeof ( out_str ), str , ap ); while ( * ptr != '\\0' ) { usart_serial_putchar ( CONSOLE_UART , * ptr ); ++ ptr ; } } static void data_printer ( const char * str , ...) { va_list ap ; va_start ( ap , str ); console_printer ( str , ap ); va_end ( ap ); } void event_printer ( const inv_sensor_event_t * event ) { if ( event -> sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER ) { data_printer ( \"ACC_RAW,%d,%d,%d \\r\\n \" , event -> data . raw3d . vect [ 0 ], event -> data . raw3d . vect [ 1 ], event -> data . raw3d . vect [ 2 ] ); } } Repo of the modified project The modifications are tracked in a repo at: https://github.com/vuquangtrong/eMD-SmartMotion_ICM207xx . The output Here is an example of outputting 4 data types from sensor: Calibrated Accelerator Calibrated Gyroscope Game Rotation Vector Linear Acceleration Data types output from ICM-20789 sensor","title":"2. Modify the project"},{"location":"imu/#3-output-raw-data","text":"","title":"3. Output raw data"},{"location":"imu/#4-appendix","text":"Digital Motion Processor The embedded Digital Motion Processor (DMP) offloads computation of motion processing algorithms from the host processor. The DMP acquires data from the accelerometer and gyroscope, processes the data, and the results can be read from the FIFO. The DMP has access to one of the external pins, which can be used for generating interrupts. The purpose of the DMP is to offload both timing requirements and processing power from the host processor. Typically, motion processing algorithms should be run at a high rate, often around 200 Hz to provide accurate results with low latency. This is required even if the application updates at a much lower rate; for example, a low power user interface may update as slowly as 5 Hz, but the motion processing should still run at 200 Hz. The DMP can be used to minimize power, simplify timing, simplify the software architecture, and save valuable MIPS on the host processor for use in applications. DMP operation is possible in low-power gyroscope and low-power accelerometer modes.","title":"4. Appendix"},{"location":"mapping/","text":"","title":"Mapping"},{"location":"notes/","text":"1. Check log \u2693\ufe0e dmesg cat /var/log/syslog 2. List builtin modules \u2693\ufe0e cat /lib/modules/ $( uname -r ) /modules.builtin | grep spi kernel/drivers/media/spi/imx204.ko kernel/drivers/mtd/devices/qspi_mtd.ko kernel/drivers/mtd/spi-nor/spi-nor.ko kernel/drivers/spi/spi-tegra114.ko kernel/drivers/spi/spi-tegra124-slave.ko kernel/drivers/spi/spi-tegra210-qspi.ko 3. Build kernel and modules \u2693\ufe0e This is a method to build Kernel image and modules directly on the Jetson board. Firstly, clone build scripts: git clone https://github.com/jetsonhacks/jetson-linux-build.git cd jetson-linux-build Download kernel source. The script will automatically detects the kernel version. ./getKernelSources.sh Kernel modules can be configured using KConfig Menu: ./editConfig.sh Let's get example of revieing SPI driver for Tegra114. Browse to Device Drivers > SPI support and check detail of NVIDIA Tegra114 SPI Controller by pressing H : .config - Linux/arm64 4.9.140 Kernel Configuration > Device Drivers > SPI support ------------ ------NVIDIA Tegra114 SPI Controller------- \u2502 CONFIG_SPI_TEGRA114: \u2502 \u2502 \u2502 \u2502 Symbol: SPI_TEGRA114 [=y] \u2502 \u2502 Type : tristate \u2502 \u2502 Prompt: NVIDIA Tegra114 SPI Controller \u2502 \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> SPI support (SPI [=y]) \u2502 \u2502 Defined at drivers/spi/Kconfig:626 \u2502 \u2502 Depends on:... This driver use the symbol SPI_TEGRA114 which is defined at drivers/spi/Kconfig:626 . Check the Makefile in /usr/src/kernel/$(uname -r)/drivers/spi/Makefile : obj-$(CONFIG_SPI_MASTER) += spi.o obj-$(CONFIG_SPI_SPIDEV) += spidev.o obj-$(CONFIG_SPI_LOOPBACK_TEST) += spi-loopback-test.o obj-$(CONFIG_SPI_TEGRA114) += spi-tegra114.o Trace to .config file in the kernel folder /usr/src/kernel/$(uname -r) . Read more at Makefile . CONFIG_SPI = y CONFIG_SPI_MASTER = y CONFIG_SPI_SPIDEV = m # CONFIG_SPI_LOOPBACK_TEST is not set CONFIG_SPI_TEGRA114 = y The CONFIG_SPI_TEGRA114=y means spi_tegra114 is a platform driver , not a module, therefore it needs to rebuild kernel image to include change in that driver. Edit the source code or apply a patch: sudo patch -p1 < spi1.patch Build kernel image ./makeKernel.sh It takes about 56 mins at the first time. Replace BOOT image at line LINUX /boot/Image by editing the boot file cat /boot/extlinux/extlinux.conf . Should back up the kernel image first. Reboot! 4. Find in file \u2693\ufe0e grep --include=\\*.{c,h} -rnw '.' -e \"SPI_MODE_1\" 5. Check shared libs \u2693\ufe0e ld -lrf24 --verbose 6. Wrap C lib to C++ lib \u2693\ufe0e Add wrapper to the header file #ifdef __cplusplus extern \"C\" { #endif ... header content here ... #ifdef __cplusplus } #endif 7. Device Tree Compile \u2693\ufe0e Decompile: dtc -I dtb -O dts <input.dtb> -o <output.dts> Edit .dts file, and then recompile: dtc -I dts -O dtb <input.dts> -o <output.dtb> Replace FDT file at line FDT /boot/xxx.dtb by editing the boot file cat /boot/extlinux/extlinux.conf . Should back up the kernel image first. 8. Fix USB Partition \u2693\ufe0e USB with wrong partition table can not be read. Erase the entire partition table is needed. sudo dd if = /dev/zero of = /dev/sda bs = 512 count = 1 Then use fdisk to create GPT partition table and add new partition. sudo fdisk /dev/sdx The format the partition: sudo mkfs.ext4 /dev/sdxy 9. Install Visual Studio Code \u2693\ufe0e wget -N -O vscode-linux-deb.arm64.deb https://update.code.visualstudio.com/latest/linux-deb-arm64/stable sudo apt install ./vscode-linux-deb.arm64.deb rm vscode-linux-deb.arm64.deb 10. Submodule in Git \u2693\ufe0e git submodule add <remote_url> git submodule deinit <submodule_name>","title":"Notes"},{"location":"notes/#1-check-log","text":"dmesg cat /var/log/syslog","title":"1. Check log"},{"location":"notes/#2-list-builtin-modules","text":"cat /lib/modules/ $( uname -r ) /modules.builtin | grep spi kernel/drivers/media/spi/imx204.ko kernel/drivers/mtd/devices/qspi_mtd.ko kernel/drivers/mtd/spi-nor/spi-nor.ko kernel/drivers/spi/spi-tegra114.ko kernel/drivers/spi/spi-tegra124-slave.ko kernel/drivers/spi/spi-tegra210-qspi.ko","title":"2. List builtin modules"},{"location":"notes/#3-build-kernel-and-modules","text":"This is a method to build Kernel image and modules directly on the Jetson board. Firstly, clone build scripts: git clone https://github.com/jetsonhacks/jetson-linux-build.git cd jetson-linux-build Download kernel source. The script will automatically detects the kernel version. ./getKernelSources.sh Kernel modules can be configured using KConfig Menu: ./editConfig.sh Let's get example of revieing SPI driver for Tegra114. Browse to Device Drivers > SPI support and check detail of NVIDIA Tegra114 SPI Controller by pressing H : .config - Linux/arm64 4.9.140 Kernel Configuration > Device Drivers > SPI support ------------ ------NVIDIA Tegra114 SPI Controller------- \u2502 CONFIG_SPI_TEGRA114: \u2502 \u2502 \u2502 \u2502 Symbol: SPI_TEGRA114 [=y] \u2502 \u2502 Type : tristate \u2502 \u2502 Prompt: NVIDIA Tegra114 SPI Controller \u2502 \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> SPI support (SPI [=y]) \u2502 \u2502 Defined at drivers/spi/Kconfig:626 \u2502 \u2502 Depends on:... This driver use the symbol SPI_TEGRA114 which is defined at drivers/spi/Kconfig:626 . Check the Makefile in /usr/src/kernel/$(uname -r)/drivers/spi/Makefile : obj-$(CONFIG_SPI_MASTER) += spi.o obj-$(CONFIG_SPI_SPIDEV) += spidev.o obj-$(CONFIG_SPI_LOOPBACK_TEST) += spi-loopback-test.o obj-$(CONFIG_SPI_TEGRA114) += spi-tegra114.o Trace to .config file in the kernel folder /usr/src/kernel/$(uname -r) . Read more at Makefile . CONFIG_SPI = y CONFIG_SPI_MASTER = y CONFIG_SPI_SPIDEV = m # CONFIG_SPI_LOOPBACK_TEST is not set CONFIG_SPI_TEGRA114 = y The CONFIG_SPI_TEGRA114=y means spi_tegra114 is a platform driver , not a module, therefore it needs to rebuild kernel image to include change in that driver. Edit the source code or apply a patch: sudo patch -p1 < spi1.patch Build kernel image ./makeKernel.sh It takes about 56 mins at the first time. Replace BOOT image at line LINUX /boot/Image by editing the boot file cat /boot/extlinux/extlinux.conf . Should back up the kernel image first. Reboot!","title":"3. Build kernel and modules"},{"location":"notes/#4-find-in-file","text":"grep --include=\\*.{c,h} -rnw '.' -e \"SPI_MODE_1\"","title":"4. Find in file"},{"location":"notes/#5-check-shared-libs","text":"ld -lrf24 --verbose","title":"5. Check shared libs"},{"location":"notes/#6-wrap-c-lib-to-c-lib","text":"Add wrapper to the header file #ifdef __cplusplus extern \"C\" { #endif ... header content here ... #ifdef __cplusplus } #endif","title":"6. Wrap C lib to C++ lib"},{"location":"notes/#7-device-tree-compile","text":"Decompile: dtc -I dtb -O dts <input.dtb> -o <output.dts> Edit .dts file, and then recompile: dtc -I dts -O dtb <input.dts> -o <output.dtb> Replace FDT file at line FDT /boot/xxx.dtb by editing the boot file cat /boot/extlinux/extlinux.conf . Should back up the kernel image first.","title":"7. Device Tree Compile"},{"location":"notes/#8-fix-usb-partition","text":"USB with wrong partition table can not be read. Erase the entire partition table is needed. sudo dd if = /dev/zero of = /dev/sda bs = 512 count = 1 Then use fdisk to create GPT partition table and add new partition. sudo fdisk /dev/sdx The format the partition: sudo mkfs.ext4 /dev/sdxy","title":"8. Fix USB Partition"},{"location":"notes/#9-install-visual-studio-code","text":"wget -N -O vscode-linux-deb.arm64.deb https://update.code.visualstudio.com/latest/linux-deb-arm64/stable sudo apt install ./vscode-linux-deb.arm64.deb rm vscode-linux-deb.arm64.deb","title":"9. Install Visual Studio Code"},{"location":"notes/#10-submodule-in-git","text":"git submodule add <remote_url> git submodule deinit <submodule_name>","title":"10. Submodule in Git"},{"location":"post-process/","text":"","title":"Post-process"},{"location":"reference/","text":"1. Overview \u2693\ufe0e The official guide and source code is hosted in livox_high_precision_mapping This project aims to stick geographical information into a point cloud. The data from GNSS and INS module is used to calculate high precision position of every point captured from the Lidar. The sample project uses a Livox Mid-40 lidar and an APX-15 GNSS-INS module. The system block diagram looks like below: Livox mapping using APX-15 The APX-15 module sends PPS pulse to Livox, and sends GPS timestamp in GNRMC messages to the Manifold 2 computer which forwards timestamp to Livox through an Ethernet connection The APX-15 module sends Trimble's GSOF messages which contains GNSS location data and IMU information to the Manifold 2 The Livox Mid-40, gets PPS and GNRMC timestamp then sends point cloud message to the Manifold 2 on the Ethernet connection The Manifold2 processes GNSS, IMU and pointcloud together to create a geo-referenced pointcloud. 2. Mapping package \u2693\ufe0e The data flow is described in the below diagram: Lidar Mapping system calls and data flow User configuration points: Turn on Timestamp Synchronization and set GNRMC input device in livox_lidar_config.json file Set GSOF input device in apx15.launch file Run the mapping_online.launch file to generate point cloud data in the pointcloud2 format that combines the IMU pose and GNSS position: roslaunch livox_mapping mapping_online.launch 3. APX-15 Node \u2693\ufe0e The APX-15 node reads GSOF messages from APX and extract the GNSS and IMU data from the Report Packet (0x40 \u2014 GENOUT) . There are 3 interesting message types: UTC message (ID = 16) INS Navigation message (ID = 49) INS RMS message (ID = 50) These extracted information will be used to make sensor_msgs::NavSatFix and sensor_msgs::Imu messages which are posted to the mapping node. Extract data from APX-15 GSOF message 4. Mapping node \u2693\ufe0e The mapping node gets the pointcloud from the Lidar ROS driver node, the GNSS and IMU data from the APX-15 node and processes them together: Store pointcloud with timestamp Store GNSS with timestamp Store IMU with timestamp Align packets using timestamp Apply IMU to GNSS point, and stick geographical information to pointcloud Combine position and pose into pointcloud","title":"Reference"},{"location":"reference/#1-overview","text":"The official guide and source code is hosted in livox_high_precision_mapping This project aims to stick geographical information into a point cloud. The data from GNSS and INS module is used to calculate high precision position of every point captured from the Lidar. The sample project uses a Livox Mid-40 lidar and an APX-15 GNSS-INS module. The system block diagram looks like below: Livox mapping using APX-15 The APX-15 module sends PPS pulse to Livox, and sends GPS timestamp in GNRMC messages to the Manifold 2 computer which forwards timestamp to Livox through an Ethernet connection The APX-15 module sends Trimble's GSOF messages which contains GNSS location data and IMU information to the Manifold 2 The Livox Mid-40, gets PPS and GNRMC timestamp then sends point cloud message to the Manifold 2 on the Ethernet connection The Manifold2 processes GNSS, IMU and pointcloud together to create a geo-referenced pointcloud.","title":"1. Overview"},{"location":"reference/#2-mapping-package","text":"The data flow is described in the below diagram: Lidar Mapping system calls and data flow User configuration points: Turn on Timestamp Synchronization and set GNRMC input device in livox_lidar_config.json file Set GSOF input device in apx15.launch file Run the mapping_online.launch file to generate point cloud data in the pointcloud2 format that combines the IMU pose and GNSS position: roslaunch livox_mapping mapping_online.launch","title":"2. Mapping package"},{"location":"reference/#3-apx-15-node","text":"The APX-15 node reads GSOF messages from APX and extract the GNSS and IMU data from the Report Packet (0x40 \u2014 GENOUT) . There are 3 interesting message types: UTC message (ID = 16) INS Navigation message (ID = 49) INS RMS message (ID = 50) These extracted information will be used to make sensor_msgs::NavSatFix and sensor_msgs::Imu messages which are posted to the mapping node. Extract data from APX-15 GSOF message","title":"3. APX-15 Node"},{"location":"reference/#4-mapping-node","text":"The mapping node gets the pointcloud from the Lidar ROS driver node, the GNSS and IMU data from the APX-15 node and processes them together: Store pointcloud with timestamp Store GNSS with timestamp Store IMU with timestamp Align packets using timestamp Apply IMU to GNSS point, and stick geographical information to pointcloud Combine position and pose into pointcloud","title":"4. Mapping node"},{"location":"rover/","text":"1. Operating System \u2693\ufe0e Original guide is at Getting Started with Jetson Nano Developer Kit . Download the latest Jetson Nano Developer Kit SD Card Image . Other older versions can be found in Jetpack Archive . Download balenaEtcher and install it, and write Jetson Image in an SD Card. A micro SDCard with at least 32GB Power on the board, either use Monitor with Keyboard and Mouse, or use Headless Mode by using DC jack (Jumper J48 connected) and connect micro-USB port to PC. Headless setup only available on the virtual COM port when power up via DC Jack! UART2 @ J50 Starting kernel ... [ 0.000000] earlycon: uart8250 at MMIO32 0x0000000070006000 (options '') [ 0.000000] bootconsole [uart8250] enabled [ 15.823522] Please complete system configuration setup on the serial port provided device mode connection. e.g. /dev/ttyACMx where x can 0, 1, 2 etc. 2. System config \u2693\ufe0e 2.1. General \u2693\ufe0e Time Mode: UTC Username: jetson Password: cccc APP Partition Size: 0 (max size) Primary Network: dummy then skip network setting (will add USB WiFi later) Hostname: rover Nvpmodel: MAXN After finishing system configuration, system console are available at: Physical UART1 at /dev/ttyTHS1 run by a service Physical UART2 at /dev/ttyS0 started by command line option Virtual COM Port at /dev/ttyGS0 run when micro-USB is connected in device mode UART ports Jetson Nano has 3 physical UART ports: UART0 at the M2 Slot for WiFi/BT card UART1 at the J41 Header (40-pin connector) for System Console after boot up (run by a service), Pin 8 - TX, Pin 10 - RX UART2 at the J50 header for debug (early access during boot from bootloader), Pin 4 - RX, Pin 5 - TX 2.2. Network \u2693\ufe0e WiFi is used for main communication with host PC, as the Ethernet port is used to connect to Lidar. Plug TP-Link WN725N USB dongle, make sure it is recognized. lsusb Bus 001 Device 004: ID 0bda:8179 Realtek Semiconductor Corp. RTL8188EUS 802.11n Wireless Network Adapter Then Wireless interface also appears and is ready to check: sudo ifconfig wlan0 up List WiFi Network sudo iwlist wlan0 scan sudo nmcli device wifi list - List info on your wifi signal Connect to an AP sudo nmcli device wifi connect \"SSID\" password \"PASSWORD\" SSH connection With network enabled, through either Ethernet or WiFi, Jetson board will be also accessed via SSH. If using any X11-forwarding SSH client, such as MobaXterm, GUI app can be show through SSH. In some case, it is recommended to turn power saving mode off sudo iw dev wlan0 set power_save off Update the system at the first time: sudo apt update Ethernet should be set to use a static IP which is in the subnet of 192.168.1.0 where Lidar is also set its IP in. Bring up the interface: sudo ifconfig eth0 up Edit the network interface: /etc/network/interfaces auto eth0 iface eth0 inet static address 192 .168.1.12 netmask 255 .255.255.0 It is needed to change network connection priority, as Linux prefers to use Ethernet when it is connected. Install ifmetric tool: sudo apt-get install ifmetric To use this, first see the metrics using route command: route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 10.42.0.1 0.0.0.0 UG 100 0 0 eth0 0.0.0.0 10.42.0.2 0.0.0.0 UG 600 0 0 wlan0 Here, eth0 has lower metric, so it will be preferred over wlan0 . If you want to prefer wlan0 , then lower its metric: sudo ifmetric wlan0 50 Now Linux will be using wlan0 for Internet. The change will be reflected immediately. 2.3. Tweaks \u2693\ufe0e To skip entering password on sudo command, add current user to sudoers with the rule NOPASSWD : sudo bash -c \"echo ' $USER ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/ $USER \" Install nano for editing in terminal sudo apt update && \\ sudo apt install nano -y To make terminal display colorfully, in .bashrc , enable force_color_prompt = yes . To disable animation on GUI: gsettings set org.gnome.desktop.interface enable-animations false 2.4. Enable GPIO \u2693\ufe0e Starting from L4T kernel 32.4.2+, the initial user created in system configuration will be added into all GPIO groups. Run groups to see the current user is added into gpio , i2c . Note that, Jetson L4T does not have spi group, SPI devices use gpio group. By default, GPIO and I2C are enabled. SPI, PWM, I2S and some extra pins are disabled. To change the setting of GPIO, the official tool jetson-io.py will be used: sudo /opt/nvidia/jetson-io/jetson-io.py This tool will configure the Device Tree and add it using FDT option in the /boot/extlinux/extlinux.conf file In Jetpack 4.6, SPI device driver are not loaded into kernel, a manual method is to run sudo modprobe spidev , but spidev should be added into /etc/modules to load that driver at boot time. sudo bash -c 'echo spidev > /etc/modules' Jetson Nano 40-pin header 3. UART Config \u2693\ufe0e 3.1. UART1 \u2693\ufe0e The stock Jetson Nano starts a console on the /dev/ttyTHS1 serial port at startup through a service /etc/systemd/nvgetty.sh which launches getty . Note that normal udev rules will be overridden by the console while the service is running. To disable the console: sudo systemctl stop nvgetty && \\ sudo systemctl disable nvgetty && \\ sudo udevadm trigger 3.2. UART2 \u2693\ufe0e The debug serial interface is chosen at the startup of kernel. From L4T kernel 32.4.2+, the debug serial can be disabled through the command line options. Here is the log of boot up process which show the configuration file and the command line: U-Boot 2020.04-g46e4604c78 (Jul 26 2021 - 12:09:42 -0700) Found /boot/extlinux/extlinux.conf append: tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 console=ttyS0,115200n8 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt earlycon=uart8250,mmio32,0x70006000 root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 quiet root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 The command line can be read from /proc/cmdline : cat /proc/cmdline Examine /boot/extlinux/extlinux.conf : /boot/extlinux/extlinux.conf TIMEOUT 30 DEFAULT primary MENU TITLE L4T boot options LABEL primary MENU LABEL primary kernel LINUX /boot/Image INITRD /boot/initrd APPEND ${cbootargs} quiet root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 Even it is impossible to edit ${cbootargs} without rebuilding kernel, it is still possible to set new command line in APPEND field. Remove ttyS0 Take the expanded command line in /proc/cmdline and remove all ttyS0 options, make a new value for APPEND file: /boot/extlinux/extlinux.conf TIMEOUT 30 DEFAULT primary MENU TITLE L4T boot options LABEL primary MENU LABEL primary kernel LINUX /boot/Image INITRD /boot/initrd APPEND tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt earlycon=uart8250,mmio32,0x70006000 console=tty0 root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 fbcon=map:0 net.ifnames=0 quiet When a cmdline's console= is set, the auto-generated serial-getty@ttyXy.service should start agetty and provide system console on that device. If there is console= option presented, system will attempt to open the first physical serial port at /dev/ttyS0 . That is the reason that, a virtual current console console=tty0 is used as the default TTY. Reboot the system. Check the dmesg log to see 3 UART ports are available. rover@jetson:~$ dmesg | grep tty [ 0.000000] Kernel command line: tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt earlycon=uart8250,mmio32,0x70006000 console=tty0 root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 fbcon=map:0 net.ifnames=0 quiet [ 0.001665] console [tty0] enabled [ 1.591294] 70006000.serial: ttyS0 at MMIO 0x70006000 (irq = 63, base_baud = 25500000) is a Tegra [ 1.592156] 70006040.serial: ttyTHS1 at MMIO 0x70006040 (irq = 64, base_baud = 0) is a TEGRA_UART [ 1.592584] 70006200.serial: ttyTHS2 at MMIO 0x70006200 (irq = 65, base_baud = 0) is a TEGRA_UART UART2 still is accessible in boot up time, as it is attached to the bootloader. Send any data at very early time will stop the auto boot. After reboot, run below command to check if there is any ttyS0 or ttyTHSx is running. It should not show any of them. ps -aux | grep tty 3.3. Permission \u2693\ufe0e To get rid of using sudo permission, add current user into the serial group. Run ls -al /dev/tty* to check the user group of ttyS0 , ttyTHS1 . Normally, it is needed to add current user into tty and dialout groups: sudo usermod -a -G tty $USER && \\ sudo usermod -a -G dialout $USER && \\ sudo reboot Test UART ports For testing, a serial terminal must be installed. Choose one of below. putty sudo apt install putty -y putty Follow GUI to run. minicom sudo apt install minicom -y minicom -D /dev/ttyS0 -b 115200 Press Ctrl-A X to exit. picocom sudo apt install picocom -y picocom /dev/ttyS0 -b 115200 Press Ctrl-A and Ctrl-X to exit. screen sudo apt install screen -y screen /dev/ttyS0 115200 Press Ctrl-A K to exit. 4. Wiring \u2693\ufe0e Refer to below pinout diagram: Rover wiring UART RX/TX problem Here is some reports showing that Jetson boards have problems on UART RX/TX pin when connecting that port directly to an other board. It maily causes by the capitive loading on the pin, if the loop-back test does not have any problem. If that problem happens, please add a 10K pull-down resister on RX/TX pin. Refer to Unreliable serial communcation via the UART TX/RX GPIO Pins . 5. Serial driver \u2693\ufe0e Download source code and build: git clone https://github.com/vuquangtrong/SerialPort.git && \\ cd SerialPort && \\ make && \\ sudo make install An example to communicate with Serial port: // Serial library #include \"serial/SerialPort.h\" #include <unistd.h> #include <stdio.h> #define SERIAL_PORT \"/dev/ttyS0\" int main ( /*int argc, char *argv[]*/ ) { SerialPort serial ; char errorOpening = serial . openDevice ( SERIAL_PORT , 115200 ); if ( errorOpening != 1 ) return errorOpening ; printf ( \"Successful connection to %s \\n \" , SERIAL_PORT ); // Display ASCII characters (from 32 to 128) for ( int c = 32 ; c < 128 ; c ++ ) { serial . writeChar ( c ); usleep ( 10000 ); } // Read lines and print them out char line [ 1024 ]; while ( 1 ) { int n = serial . readBytes ( line , sizeof ( line )); if ( n >= 0 ) { std :: cout << std :: string ( line , n ) << std :: endl ; } } // Close the serial device serial . closeDevice (); return 0 ; } Compile and run: g++ example.cpp -lserial -o example 6. nRF24L01p driver \u2693\ufe0e Download source code from GitHub and build: git clone https://github.com/vuquangtrong/RF24 && \\ cd RF24 && \\ ./configure --driver = SPIDEV && \\ make && \\ sudo make install Work with the original source code GitHub source code is at https://github.com/nRF24/RF24 . The guide to install in Linux at https://nrf24.github.io/RF24/md_docs_linux_install.html . Download the install.sh file: wget http://tmrh20.github.io/RF24Installer/RPi/install.sh Make it executable: chmod +x install.sh Run it and choose the option: RF24 Core SPIDEV driver ./install.sh Do you want to install GIT using APT (Used to download source code) [y/N]? n Do you want to install the RF24 core library, [y/N]? y Do you want to install the RF24Network library [y/N]? n Do you want to install the RF24Mesh library [y/N]? n Do you want to install the RF24Gateway library [y/N]? n Cloning into './rf24libs/RF24'... *** Install RF24 core using? *** 1.BCM2835 Driver(Performance) 2.SPIDEV(Compatibility, Default) 3.WiringPi(Its WiringPi!) 4.MRAA(Intel Devices) 5.LittleWire 2 ... [Installing Libs to /usr/local/lib] [Installing Headers to /usr/local/include/RF24] Fix CS pin Jetson Nano spi-tegra114 driver has an issue in driving the CSN pin, therefore, the SPI command must explicitly request to toggle CSN pin. Open the file ~/rf24libs/RF24/utility/SPIDEV/spi.cpp to find tr.cs_change = 0; and replace them by tr.cs_change = 1; . Go back to the `~/rf24libs/RF24 and rebuild the library: sudo make clean all install Fixed in a Seeed Studio's branch, but not in Nvidia's Refer: spi: tegra: handle cs_change in modes sw_based_cs & cs_gpios . Source to test data receiving. Check the transferring site in Base . rf24_rx.cpp #include <iostream> // cin, cout, endl #include <time.h> // CLOCK_MONOTONIC_RAW, timespec, clock_gettime() #include <RF24/RF24.h> // create RF24 instance RF24 radio ( 15 /* CE = sys_gpio_15 */ , 0 /* CSN = 0 means spidev0.0 */ /* default speed is 10 Mbps */ ); // max payload of RF24 is 32 bytes uint8_t payload [ 32 ]; uint32_t total_nrx = 0 ; // custom defined timer for evaluating transmission time in microseconds struct timespec startTimer , endTimer ; int main ( int argc , char ** argv ) { setbuf ( stdout , NULL ); // perform hardware check if ( ! radio . begin ()) { cout << \"radio hardware is not responding!!\" << endl ; return 0 ; // quit now } radio . setPayloadSize ( 32 ); radio . setChannel ( 100 ); // 2400 + 100 = 2500 MHz, out of WiFi band // address, defaut length is 5 uint8_t rx_address [ 6 ] = \"1Addr\" ; // read from radio . openReadingPipe ( 1 , rx_address ); // using pip 1 // For debugging info radio . printDetails (); // (smaller) function that prints raw register values radio . printPrettyDetails (); // (larger) function that prints human readable data // Start std :: cout << \"Start RX\" << std :: endl ; radio . startListening (); // put radio in RX mode uint8_t pipe ; uint8_t nrx ; clock_gettime ( CLOCK_MONOTONIC_RAW , & startTimer ); // start the timer cout << \"Begin: \" << startTimer . tv_sec << \".\" << startTimer . tv_nsec << endl ; while ( true ) { if ( radio . available ( & pipe )) { nrx = radio . getPayloadSize (); radio . read ( & payload , nrx ); total_nrx += nrx ; if ( total_nrx >= 1000000 ) { clock_gettime ( CLOCK_MONOTONIC_RAW , & endTimer ); // end the timer cout << \"End: \" << endTimer . tv_sec << \".\" << endTimer . tv_nsec << endl ; break ; } } } int32_t diff_sec = endTimer . tv_sec - startTimer . tv_sec ; int32_t diff_nsec = endTimer . tv_nsec - startTimer . tv_nsec ; if ( diff_nsec < 0 ) { diff_nsec = 1000000000 - diff_nsec ; diff_sec -= 1 ; } cout << \"Received 1000000 bytes in \" << diff_sec << \".\" << diff_nsec << \" seconds\" << endl ; } Compile the source code: g++ -Ofast -Wall -pthread rf24_rx.cpp -lrf24 -o rf24_rx Run it and see the log: ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO15 SPI Speedz = 10 Mhz ================ NRF Configuration ================ STATUS = 0x0e RX_DR=0 TX_DS=0 MAX_RT=0 RX_P_NO=7 TX_FULL=0 RX_ADDR_P0-1 = 0x65646f4e31 0x7264644131 RX_ADDR_P2-5 = 0xc3 0xc4 0xc5 0xc6 TX_ADDR = 0x65646f4e31 RX_PW_P0-6 = 0x20 0x20 0x20 0x20 0x20 0x20 EN_AA = 0x3f EN_RXADDR = 0x03 RF_CH = 0x64 RF_SETUP = 0x03 CONFIG = 0x0e DYNPD/FEATURE = 0x00 0x00 Data Rate = 1 MBPS Model = nRF24L01+ CRC Length = 16 bits PA Power = PA_LOW ARC = 0 ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO15 SPI Frequency = 10 Mhz ================ NRF Configuration ================ Channel = 100 (~ 2500 MHz) RF Data Rate = 1 MBPS RF Power Amplifier = PA_LOW RF Low Noise Amplifier = Enabled CRC Length = 16 bits Address Length = 5 bytes Static Payload Length = 32 bytes Auto Retry Delay = 1500 microseconds Auto Retry Attempts = 15 maximum Packets lost on current channel = 0 Retry attempts made for last transmission = 0 Multicast = Disabled Custom ACK Payload = Disabled Dynamic Payloads = Disabled Auto Acknowledgment = Enabled Primary Mode = TX TX address = 0x65646f4e31 pipe 0 ( open ) bound = 0x65646f4e31 pipe 1 ( open ) bound = 0x7264644131 pipe 2 (closed) bound = 0xc3 pipe 3 (closed) bound = 0xc4 pipe 4 (closed) bound = 0xc5 pipe 5 (closed) bound = 0xc6 Start RX Begin: 793.156527770 End: 821.645141301 Received 1000000 bytes in 28.488613531 seconds The example receives 1 MB in 28.5 seconds, which means 35 KBps. While the transfer rate set on the channel is 1Mbps (equals 125 KBps), the example only achieve 28% of bandwidth. 7. OLED driver \u2693\ufe0e Download source code and build: git clone https://github.com/vuquangtrong/OLED_SSD1306_I2C_Linux.git && \\ cd OLED_SSD1306_I2C_Linux && \\ make && \\ sudo make install Write a simple app to a progress bar with label and numeric value: progress_bar.c #include <string.h> #include <unistd.h> #include <SSD1306/ssd1306.h> int main () { char counter = 0 ; char buffer [ 3 ]; SSD1306_Init ( \"/dev/i2c-1\" ); while ( 1 ) { sprintf ( buffer , \"%d\" , counter ++ ); SSD1306_Clear (); SSD1306_WriteString ( 0 , 0 , \"counter:\" , & Font_7x10 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_WriteString ( 0 , 10 , buffer , & Font_11x18 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_DrawRectangle ( 0 , 28 , 128 , 4 , SSD1306_WHITE ); SSD1306_DrawFilledRectangle ( 0 , 28 , counter * 128 / 256 , 4 , SSD1306_WHITE ); SSD1306_Screen_Update (); sleep ( 0.2 ); } return 0 ; } Compile and run: gcc progress_bar.c -lssd1306 -o progress_bar && \\ ./progress_bar 8. ROS Melodic \u2693\ufe0e Adding repository and source list sudo apt-add-repository universe sudo apt-add-repository multiverse sudo apt-add-repository restricted sudo apt update Setup source list to get ROS packages: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Add keys: sudo apt install -y curl && \\ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Pull the package list: sudo apt update Install ROS Melodic desktop: sudo apt install -y ros-melodic-desktop It's convenient if the ROS environment variables are automatically added to a bash session every time a new shell is launched: echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc && \\ source ~/.bashrc A good way to check the installation is to ensure that environment variables like ROS_ROOT and ROS_PACKAGE_PATH are set: printenv | grep ROS ROS_ETC_DIR = /opt/ros/melodic/etc/ros ROS_ROOT = /opt/ros/melodic/share/ros ROS_MASTER_URI = http://localhost:11311 ROS_VERSION = 1 ROS_PYTHON_VERSION = 2 ROS_PACKAGE_PATH = /opt/ros/melodic/share ROSLISP_PACKAGE_DIRECTORIES = ROS_DISTRO = melodic Initialize the package rosdep to track package dependency: sudo apt install python-rosdep -y && \\ sudo rosdep init && \\ rosdep update Build packages are needed for code compilation. sudo apt install -y python-rosinstall python-rosinstall-generator python-wstool build-essential Create a catkin workspace and try to build it: mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src catkin_init_workspace cd .. catkin_make The workspace should be built successfully. 9. Livox SDK \u2693\ufe0e 9.1. Dependencies \u2693\ufe0e Livox SDK needs to be built in the host machine, therefore, some tool-chain and build tools have to be installed. sudo apt-get update && \\ sudo apt-get install -y build-essential && \\ sudo apt-get install -y curl && \\ sudo apt-get install -y git && \\ sudo apt-get install -y cmake The Point Cloud Library (PCL) is a large scale, open project[1] for point cloud processing. The PCL framework contains numerous state-of-the art algorithms including filtering, feature estimation, surface reconstruction, registration, model fitting and segmentation. sudo apt install -y libpcl-dev sudo apt install -y ros-melodic-pcl-ros Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms. sudo apt install -y libeigen3-dev OpenCV (Open Source Computer Vision Library) is an open-source computer vision library and has bindings for C++, Python, and Java. It is used for a very wide range of applications, including medical image analysis, stitching street view images, surveillance video, detecting and recognizing faces, tracking moving objects, extracting 3D models, and much more. OpenCV can take advantage of multi-core processing and features GPU acceleration for real-time operation. sudo apt install -y python-opencv python3-opencv Re-link libraries: sudo ln -s /usr/bin/vtk6 /usr/bin/vtk && \\ sudo ln -s /usr/lib/python2.7/dist-packages/vtk/libvtkRenderingPythonTkWidgets.aarch64-linux-gnu.so /usr/lib/aarch64-linux-gnu/libvtkRenderingPythonTkWidgets.so 9.2. Livox SDK \u2693\ufe0e The official guide is at https://github.com/Livox-SDK/Livox-SDK . Livox SDK is the software development kit designed for all Livox products. It is developed based on C/C++ following Livox SDK Communication Protocol, and provides easy-to-use C style API. With Livox SDK, users can quickly connect to Livox products and receive point cloud data. Installation git clone https://github.com/Livox-SDK/Livox-SDK.git && \\ cd Livox-SDK && \\ cd build && \\ cmake .. && \\ make && \\ sudo make install The Livox SDK will be built and installed in /usr/local/lib : Install the project... -- Install configuration: \"\" -- Installing: /usr/local/lib/liblivox_sdk_static.a -- Installing: /usr/local/include/livox_def.h -- Installing: /usr/local/include/livox_sdk.h 10. Livox ROS driver \u2693\ufe0e Get livox_ros_driver from GitHub git clone https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src Then build it: cd ws_livox && \\ catkin_make If running catkin_make gives error of command not found, it's probably that the ROS setup.bash is not executed and included in ~/.bashrc . See above section to source it. This driver will create a new node named livox_lidar_publisher , which publishes 2 new types of messages: Livox Point Cloud message # Livox publish pointcloud msg format. Header header # ROS standard message header uint64 timebase # The time of first point uint32 point_num # Total number of pointclouds uint8 lidar_id # Lidar device id number uint8 [ 3 ] rsvd # Reserved use CustomPoint [] points # Pointcloud data Livox Point # Livox custom pointcloud format. uint32 offset_time # offset time relative to the base time float32 x # X axis, unit:m float32 y # Y axis, unit:m float32 z # Z axis, unit:m uint8 reflectivity # reflectivity, 0~255 uint8 tag # livox tag uint8 line # laser number in lidar 10.1. Configurations \u2693\ufe0e The configuration file is in ws_livox/src/livox_ros_driver/config . LiDAR's configuration parameter Parameter Type Description Default broadcast_code String LiDAR broadcast code N/A enable_connect Boolean false return_mode Int Return mode: 0 -- First single return mode 1 -- The strongest single return mode 2 -- Dual return mode 0 coordinate Int Coordinate: 0 -- Cartesian 1 -- Spherical 0 imu_rate Int Push frequency of IMU sensor data: 0 -- stop push 1 -- 200 Hz Currently only Horizon supports this, MID serials do not support it 0 extrinsic_parameter_source Int Whether to enable extrinsic parameter automatic compensation of LiDAR external reference 0 -- Disabled 1 -- Enabled 0 Timestamp synchronization Parameter Type Description Default enable_timesync Boolean false device_name String Name of the serial device which outputs GPRMC/GNRMC messages every second /dev/ttyUSB0 comm_device_type Int Type of device sending timestamp information 0 -- Serial port or USB virtual serial port device other -- not support 0 baudrate_index Int Baud rate of serial device: 0 -- 2400 1 -- 4800 2 -- 9600 3 -- 19200 4 -- 38400 5 -- 57600 6 -- 115200 7 -- 230400 8 -- 460800 9 -- 500000 10 -- 576000 11 -- 921600 2 (9600) parity_index Int parity type 0 -- 8 bits data without parity 1 -- 7 bits data 1bit even parity 2 -- 7 bits data 1bit odd parity 3 -- 7 bits data 1bit 0, without parity 0 livox_lidar_config.json { \"lidar_config\" : [ { \"broadcast_code\" : \"1PQDH5B00100041\" , \"enable_connect\" : false , \"return_mode\" : 0 , \"coordinate\" : 0 , \"imu_rate\" : 0 , \"extrinsic_parameter_source\" : 0 , \"enable_high_sensitivity\" : false } ], \"timesync_config\" : { \"enable_timesync\" : false , \"device_name\" : \"/dev/ttyUSB0\" , \"comm_device_type\" : 0 , \"baudrate_index\" : 2 , \"parity_index\" : 0 } } 10.2. Timestamp \u2693\ufe0e Prepare a GPS device to ensure that the GPS can output UTC time information in GPRMC/GNRMC format through the serial port or USB virtual serial port, and support PPS signal output. Connect the GPS serial port to the host running livox_ros_driver , set the corresponding device name in the config file Connect the GPS PPS signal line to LiDAR Be sure to set the output frequency of GPRMC/GNRMC time information of GPS to 1Hz 10.3. Launches \u2693\ufe0e Different launch files have different configuration parameter values and are used in different scenarios: Launch file name Description livox_lidar.launch Connect to Livox LiDAR device Publish pointcloud2 format data livox_lidar_msg.launch Connect to Livox LiDAR device Publish livox customized pointcloud data livox_lidar_rviz.launch Connect to Livox LiDAR device Publish pointcloud2 format data Autoload rviz Launch parameters Parameter Description Default publish_freq Set the frequency of point cloud publish 10.0 multi_topic 0 -- All LiDAR devices use the same topic to publish point cloud data 1 -- Each LiDAR device has its own topic to publish point cloud data 0 xfer_format 0 -- Livox pointcloud2 ( PointXYZRTL ) point cloud format 1 -- Livox customized point cloud format 2 -- Standard pointcloud2 ( PointXYZI ) point cloud format in the PCL library 0 10.4. Test ROS \u2693\ufe0e An easy method to connect Livox Lidar with Jetson board is through a LAN router. Below section shows another method to connect 2 modules directly. Set Livox's Static IP Use Livox Viewer to set a Static IP for the Lidar module. Livox only accepts IP in 192.168.1.0 network. Set Jetson's Static IP sudo nano /etc/network/interfaces /etc/network/interfaces auto lo iface lo inet loopback auto eth0 iface eth0 inet static address 192.168.1.12 netmask 255.255.255.0 Then run the livox_lidar_rviz example cd ws_livox source ./devel/setup.bash roslaunch livox_ros_driver livox_lidar_rviz.launch This will run Livox ROS and Rviz to visualize the received pointcloud. 11. Auto-mount USB \u2693\ufe0e Check out and install: git clone https://github.com/vuquangtrong/USB_Automount.git cd USB_Automount ./install Plugged-in USB will be mounted into /media/<Label> or /media/<sdXy> . Details Here are scripts to auto-mount storage devices: sudo nano /usr/local/bin/usb-mount.sh usb-mount.sh #!/bin/bash # This script is called from our systemd unit file to mount or unmount # a USB drive. usage () { echo \"Usage: $0 {add|remove} device_name (e.g. sdb1)\" exit 1 } if [[ $# -ne 2 ]] ; then usage fi ACTION = $1 DEVBASE = $2 DEVICE = \"/dev/ ${ DEVBASE } \" # See if this drive is already mounted, and if so where MOUNT_POINT = $( /bin/mount | /bin/grep ${ DEVICE } | /usr/bin/awk '{ print $3 }' ) do_mount () { if [[ -n ${ MOUNT_POINT } ]] ; then echo \"Warning: ${ DEVICE } is already mounted at ${ MOUNT_POINT } \" exit 1 fi # Get info for this drive: $ID_FS_LABEL, $ID_FS_UUID, and $ID_FS_TYPE eval $( /sbin/blkid -o udev ${ DEVICE } ) # Figure out a mount point to use LABEL = ${ ID_FS_LABEL } if [[ -z \" ${ LABEL } \" ]] ; then LABEL = ${ DEVBASE } elif /bin/grep -q \" /media/ ${ LABEL } \" /etc/mtab ; then # Already in use, make a unique one LABEL += \"- ${ DEVBASE } \" fi MOUNT_POINT = \"/media/ ${ LABEL } \" echo \"Mount point: ${ MOUNT_POINT } \" /bin/mkdir -p ${ MOUNT_POINT } # Global mount options OPTS = \"rw,relatime\" # File system type specific mount options if [[ ${ ID_FS_TYPE } == \"vfat\" ]] ; then OPTS += \",users,gid=100,umask=000,shortname=mixed,utf8=1,flush\" fi if ! /bin/mount -o ${ OPTS } ${ DEVICE } ${ MOUNT_POINT } ; then echo \"Error mounting ${ DEVICE } (status = $? )\" /bin/rmdir ${ MOUNT_POINT } exit 1 fi echo \"**** Mounted ${ DEVICE } at ${ MOUNT_POINT } ****\" } do_unmount () { if [[ -z ${ MOUNT_POINT } ]] ; then echo \"Warning: ${ DEVICE } is not mounted\" else /bin/umount -l ${ DEVICE } echo \"**** Unmounted ${ DEVICE } \" fi # Delete all empty dirs in /media that aren't being used as mount # points. This is kind of overkill, but if the drive was unmounted # prior to removal we no longer know its mount point, and we don't # want to leave it orphaned... for f in /media/* ; do if [[ -n $( /usr/bin/find \" $f \" -maxdepth 0 -type d -empty ) ]] ; then if ! /bin/grep -q \" $f \" /etc/mtab ; then echo \"**** Removing mount point $f \" /bin/rmdir \" $f \" fi fi done } case \" ${ ACTION } \" in add ) do_mount ;; remove ) do_unmount ;; * ) usage ;; esac Change permission: sudo chmod 0755 /usr/local/bin/usb-mount.sh Add service: sudo nano /etc/systemd/system/usb-mount@.service usb-mount@.service [Unit] Description = Mount USB Drive on %i [Service] Type = oneshot RemainAfterExit = true ExecStart = /usr/local/bin/usb-mount.sh add %i ExecStop = /usr/local/bin/usb-mount.sh remove %i The file name uses @ to pass arguments. Add rules for udev when USB event is detected: sudo nano /etc/udev/rules.d/99-usb-mount.rules 99-usb-mount.rules KERNEL = =\"sd[a-z][0-9]\", SUBSYSTEMS==\"usb\", ACTION==\"add\", RUN+=\"/bin/systemctl start usb-mount@%k.service\" KERNEL = =\"sd[a-z][0-9]\", SUBSYSTEMS==\"usb\", ACTION==\"remove\", RUN+=\"/bin/systemctl stop usb-mount@%k.service\" Restart services and rules: sudo udevadm control --reload-rules && \\ sudo systemctl daemon-reload If a USB is not mount automatically, check the system log: cat /var/log/syslog 12. Auto-start application \u2693\ufe0e A simple app that shows IP Address on OLED screen. ipshow.cpp #include <iostream> #include <string> #include <cstring> #include <sys/socket.h> #include <netinet/in.h> #include <arpa/inet.h> #include <unistd.h> #include <sys/types.h> #include <ifaddrs.h> #include <SSD1306/ssd1306.h> using namespace std ; char i2c_dev [] = \"/dev/i2c-1\" ; char noIP [] = \"No IP\" ; void showIP ( int line , char type , char * ip ) { char buffer [ 32 ] = { 0 }; sprintf ( buffer , \"%c:%s\" , type , ip ); SSD1306_WriteString ( 0 , line * 10 , buffer , & Font_7x10 , SSD1306_WHITE , SSD1306_OVERRIDE ); } void getIPAddresses () { struct ifaddrs * interfaces = NULL ; struct ifaddrs * temp_addr = NULL ; int success = 0 ; bool found = false ; // retrieve the current interfaces - returns 0 on success success = getifaddrs ( & interfaces ); if ( success == 0 ) { // Loop through linked list of interfaces temp_addr = interfaces ; while ( temp_addr != NULL ) { if ( temp_addr -> ifa_addr -> sa_family == AF_INET ) { // Check if interface is en0 which is the wifi connection on the iPhone if ( strcmp ( temp_addr -> ifa_name , \"wlan0\" ) == 0 ){ showIP ( 0 , 'W' , inet_ntoa ((( struct sockaddr_in * ) temp_addr -> ifa_addr ) -> sin_addr ) ); found = true ; } if ( strcmp ( temp_addr -> ifa_name , \"eth0\" ) == 0 ){ showIP ( 1 , 'E' , inet_ntoa ((( struct sockaddr_in * ) temp_addr -> ifa_addr ) -> sin_addr ) ); found = true ; } } temp_addr = temp_addr -> ifa_next ; } } // Free memory freeifaddrs ( interfaces ); if ( ! found ) { showIP ( 3 , '?' , noIP ); } } int main ( int argc , char ** argv ) { SSD1306_Init ( i2c_dev ); while ( 1 ) { SSD1306_Clear (); getIPAddresses (); SSD1306_Screen_Update (); sleep ( 10 ); } } Create a service: ipshow.service [Unit] Description = IP Show After = multi-user.target [Service] Type = simple ExecStart = /usr/bin/ipshow [Install] WantedBy = multi-user.target Enable the service: sudo systemctl enable ipshow.service","title":"Rover"},{"location":"rover/#1-operating-system","text":"Original guide is at Getting Started with Jetson Nano Developer Kit . Download the latest Jetson Nano Developer Kit SD Card Image . Other older versions can be found in Jetpack Archive . Download balenaEtcher and install it, and write Jetson Image in an SD Card. A micro SDCard with at least 32GB Power on the board, either use Monitor with Keyboard and Mouse, or use Headless Mode by using DC jack (Jumper J48 connected) and connect micro-USB port to PC. Headless setup only available on the virtual COM port when power up via DC Jack! UART2 @ J50 Starting kernel ... [ 0.000000] earlycon: uart8250 at MMIO32 0x0000000070006000 (options '') [ 0.000000] bootconsole [uart8250] enabled [ 15.823522] Please complete system configuration setup on the serial port provided device mode connection. e.g. /dev/ttyACMx where x can 0, 1, 2 etc.","title":"1. Operating System"},{"location":"rover/#2-system-config","text":"","title":"2. System config"},{"location":"rover/#21-general","text":"Time Mode: UTC Username: jetson Password: cccc APP Partition Size: 0 (max size) Primary Network: dummy then skip network setting (will add USB WiFi later) Hostname: rover Nvpmodel: MAXN After finishing system configuration, system console are available at: Physical UART1 at /dev/ttyTHS1 run by a service Physical UART2 at /dev/ttyS0 started by command line option Virtual COM Port at /dev/ttyGS0 run when micro-USB is connected in device mode UART ports Jetson Nano has 3 physical UART ports: UART0 at the M2 Slot for WiFi/BT card UART1 at the J41 Header (40-pin connector) for System Console after boot up (run by a service), Pin 8 - TX, Pin 10 - RX UART2 at the J50 header for debug (early access during boot from bootloader), Pin 4 - RX, Pin 5 - TX","title":"2.1. General"},{"location":"rover/#22-network","text":"WiFi is used for main communication with host PC, as the Ethernet port is used to connect to Lidar. Plug TP-Link WN725N USB dongle, make sure it is recognized. lsusb Bus 001 Device 004: ID 0bda:8179 Realtek Semiconductor Corp. RTL8188EUS 802.11n Wireless Network Adapter Then Wireless interface also appears and is ready to check: sudo ifconfig wlan0 up List WiFi Network sudo iwlist wlan0 scan sudo nmcli device wifi list - List info on your wifi signal Connect to an AP sudo nmcli device wifi connect \"SSID\" password \"PASSWORD\" SSH connection With network enabled, through either Ethernet or WiFi, Jetson board will be also accessed via SSH. If using any X11-forwarding SSH client, such as MobaXterm, GUI app can be show through SSH. In some case, it is recommended to turn power saving mode off sudo iw dev wlan0 set power_save off Update the system at the first time: sudo apt update Ethernet should be set to use a static IP which is in the subnet of 192.168.1.0 where Lidar is also set its IP in. Bring up the interface: sudo ifconfig eth0 up Edit the network interface: /etc/network/interfaces auto eth0 iface eth0 inet static address 192 .168.1.12 netmask 255 .255.255.0 It is needed to change network connection priority, as Linux prefers to use Ethernet when it is connected. Install ifmetric tool: sudo apt-get install ifmetric To use this, first see the metrics using route command: route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 10.42.0.1 0.0.0.0 UG 100 0 0 eth0 0.0.0.0 10.42.0.2 0.0.0.0 UG 600 0 0 wlan0 Here, eth0 has lower metric, so it will be preferred over wlan0 . If you want to prefer wlan0 , then lower its metric: sudo ifmetric wlan0 50 Now Linux will be using wlan0 for Internet. The change will be reflected immediately.","title":"2.2. Network"},{"location":"rover/#23-tweaks","text":"To skip entering password on sudo command, add current user to sudoers with the rule NOPASSWD : sudo bash -c \"echo ' $USER ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/ $USER \" Install nano for editing in terminal sudo apt update && \\ sudo apt install nano -y To make terminal display colorfully, in .bashrc , enable force_color_prompt = yes . To disable animation on GUI: gsettings set org.gnome.desktop.interface enable-animations false","title":"2.3. Tweaks"},{"location":"rover/#24-enable-gpio","text":"Starting from L4T kernel 32.4.2+, the initial user created in system configuration will be added into all GPIO groups. Run groups to see the current user is added into gpio , i2c . Note that, Jetson L4T does not have spi group, SPI devices use gpio group. By default, GPIO and I2C are enabled. SPI, PWM, I2S and some extra pins are disabled. To change the setting of GPIO, the official tool jetson-io.py will be used: sudo /opt/nvidia/jetson-io/jetson-io.py This tool will configure the Device Tree and add it using FDT option in the /boot/extlinux/extlinux.conf file In Jetpack 4.6, SPI device driver are not loaded into kernel, a manual method is to run sudo modprobe spidev , but spidev should be added into /etc/modules to load that driver at boot time. sudo bash -c 'echo spidev > /etc/modules' Jetson Nano 40-pin header","title":"2.4. Enable GPIO"},{"location":"rover/#3-uart-config","text":"","title":"3. UART Config"},{"location":"rover/#31-uart1","text":"The stock Jetson Nano starts a console on the /dev/ttyTHS1 serial port at startup through a service /etc/systemd/nvgetty.sh which launches getty . Note that normal udev rules will be overridden by the console while the service is running. To disable the console: sudo systemctl stop nvgetty && \\ sudo systemctl disable nvgetty && \\ sudo udevadm trigger","title":"3.1. UART1"},{"location":"rover/#32-uart2","text":"The debug serial interface is chosen at the startup of kernel. From L4T kernel 32.4.2+, the debug serial can be disabled through the command line options. Here is the log of boot up process which show the configuration file and the command line: U-Boot 2020.04-g46e4604c78 (Jul 26 2021 - 12:09:42 -0700) Found /boot/extlinux/extlinux.conf append: tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 console=ttyS0,115200n8 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt earlycon=uart8250,mmio32,0x70006000 root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 quiet root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 The command line can be read from /proc/cmdline : cat /proc/cmdline Examine /boot/extlinux/extlinux.conf : /boot/extlinux/extlinux.conf TIMEOUT 30 DEFAULT primary MENU TITLE L4T boot options LABEL primary MENU LABEL primary kernel LINUX /boot/Image INITRD /boot/initrd APPEND ${cbootargs} quiet root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 Even it is impossible to edit ${cbootargs} without rebuilding kernel, it is still possible to set new command line in APPEND field. Remove ttyS0 Take the expanded command line in /proc/cmdline and remove all ttyS0 options, make a new value for APPEND file: /boot/extlinux/extlinux.conf TIMEOUT 30 DEFAULT primary MENU TITLE L4T boot options LABEL primary MENU LABEL primary kernel LINUX /boot/Image INITRD /boot/initrd APPEND tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt earlycon=uart8250,mmio32,0x70006000 console=tty0 root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 fbcon=map:0 net.ifnames=0 quiet When a cmdline's console= is set, the auto-generated serial-getty@ttyXy.service should start agetty and provide system console on that device. If there is console= option presented, system will attempt to open the first physical serial port at /dev/ttyS0 . That is the reason that, a virtual current console console=tty0 is used as the default TTY. Reboot the system. Check the dmesg log to see 3 UART ports are available. rover@jetson:~$ dmesg | grep tty [ 0.000000] Kernel command line: tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt earlycon=uart8250,mmio32,0x70006000 console=tty0 root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 fbcon=map:0 net.ifnames=0 quiet [ 0.001665] console [tty0] enabled [ 1.591294] 70006000.serial: ttyS0 at MMIO 0x70006000 (irq = 63, base_baud = 25500000) is a Tegra [ 1.592156] 70006040.serial: ttyTHS1 at MMIO 0x70006040 (irq = 64, base_baud = 0) is a TEGRA_UART [ 1.592584] 70006200.serial: ttyTHS2 at MMIO 0x70006200 (irq = 65, base_baud = 0) is a TEGRA_UART UART2 still is accessible in boot up time, as it is attached to the bootloader. Send any data at very early time will stop the auto boot. After reboot, run below command to check if there is any ttyS0 or ttyTHSx is running. It should not show any of them. ps -aux | grep tty","title":"3.2. UART2"},{"location":"rover/#33-permission","text":"To get rid of using sudo permission, add current user into the serial group. Run ls -al /dev/tty* to check the user group of ttyS0 , ttyTHS1 . Normally, it is needed to add current user into tty and dialout groups: sudo usermod -a -G tty $USER && \\ sudo usermod -a -G dialout $USER && \\ sudo reboot Test UART ports For testing, a serial terminal must be installed. Choose one of below. putty sudo apt install putty -y putty Follow GUI to run. minicom sudo apt install minicom -y minicom -D /dev/ttyS0 -b 115200 Press Ctrl-A X to exit. picocom sudo apt install picocom -y picocom /dev/ttyS0 -b 115200 Press Ctrl-A and Ctrl-X to exit. screen sudo apt install screen -y screen /dev/ttyS0 115200 Press Ctrl-A K to exit.","title":"3.3. Permission"},{"location":"rover/#4-wiring","text":"Refer to below pinout diagram: Rover wiring UART RX/TX problem Here is some reports showing that Jetson boards have problems on UART RX/TX pin when connecting that port directly to an other board. It maily causes by the capitive loading on the pin, if the loop-back test does not have any problem. If that problem happens, please add a 10K pull-down resister on RX/TX pin. Refer to Unreliable serial communcation via the UART TX/RX GPIO Pins .","title":"4. Wiring"},{"location":"rover/#5-serial-driver","text":"Download source code and build: git clone https://github.com/vuquangtrong/SerialPort.git && \\ cd SerialPort && \\ make && \\ sudo make install An example to communicate with Serial port: // Serial library #include \"serial/SerialPort.h\" #include <unistd.h> #include <stdio.h> #define SERIAL_PORT \"/dev/ttyS0\" int main ( /*int argc, char *argv[]*/ ) { SerialPort serial ; char errorOpening = serial . openDevice ( SERIAL_PORT , 115200 ); if ( errorOpening != 1 ) return errorOpening ; printf ( \"Successful connection to %s \\n \" , SERIAL_PORT ); // Display ASCII characters (from 32 to 128) for ( int c = 32 ; c < 128 ; c ++ ) { serial . writeChar ( c ); usleep ( 10000 ); } // Read lines and print them out char line [ 1024 ]; while ( 1 ) { int n = serial . readBytes ( line , sizeof ( line )); if ( n >= 0 ) { std :: cout << std :: string ( line , n ) << std :: endl ; } } // Close the serial device serial . closeDevice (); return 0 ; } Compile and run: g++ example.cpp -lserial -o example","title":"5. Serial driver"},{"location":"rover/#6-nrf24l01p-driver","text":"Download source code from GitHub and build: git clone https://github.com/vuquangtrong/RF24 && \\ cd RF24 && \\ ./configure --driver = SPIDEV && \\ make && \\ sudo make install Work with the original source code GitHub source code is at https://github.com/nRF24/RF24 . The guide to install in Linux at https://nrf24.github.io/RF24/md_docs_linux_install.html . Download the install.sh file: wget http://tmrh20.github.io/RF24Installer/RPi/install.sh Make it executable: chmod +x install.sh Run it and choose the option: RF24 Core SPIDEV driver ./install.sh Do you want to install GIT using APT (Used to download source code) [y/N]? n Do you want to install the RF24 core library, [y/N]? y Do you want to install the RF24Network library [y/N]? n Do you want to install the RF24Mesh library [y/N]? n Do you want to install the RF24Gateway library [y/N]? n Cloning into './rf24libs/RF24'... *** Install RF24 core using? *** 1.BCM2835 Driver(Performance) 2.SPIDEV(Compatibility, Default) 3.WiringPi(Its WiringPi!) 4.MRAA(Intel Devices) 5.LittleWire 2 ... [Installing Libs to /usr/local/lib] [Installing Headers to /usr/local/include/RF24] Fix CS pin Jetson Nano spi-tegra114 driver has an issue in driving the CSN pin, therefore, the SPI command must explicitly request to toggle CSN pin. Open the file ~/rf24libs/RF24/utility/SPIDEV/spi.cpp to find tr.cs_change = 0; and replace them by tr.cs_change = 1; . Go back to the `~/rf24libs/RF24 and rebuild the library: sudo make clean all install Fixed in a Seeed Studio's branch, but not in Nvidia's Refer: spi: tegra: handle cs_change in modes sw_based_cs & cs_gpios . Source to test data receiving. Check the transferring site in Base . rf24_rx.cpp #include <iostream> // cin, cout, endl #include <time.h> // CLOCK_MONOTONIC_RAW, timespec, clock_gettime() #include <RF24/RF24.h> // create RF24 instance RF24 radio ( 15 /* CE = sys_gpio_15 */ , 0 /* CSN = 0 means spidev0.0 */ /* default speed is 10 Mbps */ ); // max payload of RF24 is 32 bytes uint8_t payload [ 32 ]; uint32_t total_nrx = 0 ; // custom defined timer for evaluating transmission time in microseconds struct timespec startTimer , endTimer ; int main ( int argc , char ** argv ) { setbuf ( stdout , NULL ); // perform hardware check if ( ! radio . begin ()) { cout << \"radio hardware is not responding!!\" << endl ; return 0 ; // quit now } radio . setPayloadSize ( 32 ); radio . setChannel ( 100 ); // 2400 + 100 = 2500 MHz, out of WiFi band // address, defaut length is 5 uint8_t rx_address [ 6 ] = \"1Addr\" ; // read from radio . openReadingPipe ( 1 , rx_address ); // using pip 1 // For debugging info radio . printDetails (); // (smaller) function that prints raw register values radio . printPrettyDetails (); // (larger) function that prints human readable data // Start std :: cout << \"Start RX\" << std :: endl ; radio . startListening (); // put radio in RX mode uint8_t pipe ; uint8_t nrx ; clock_gettime ( CLOCK_MONOTONIC_RAW , & startTimer ); // start the timer cout << \"Begin: \" << startTimer . tv_sec << \".\" << startTimer . tv_nsec << endl ; while ( true ) { if ( radio . available ( & pipe )) { nrx = radio . getPayloadSize (); radio . read ( & payload , nrx ); total_nrx += nrx ; if ( total_nrx >= 1000000 ) { clock_gettime ( CLOCK_MONOTONIC_RAW , & endTimer ); // end the timer cout << \"End: \" << endTimer . tv_sec << \".\" << endTimer . tv_nsec << endl ; break ; } } } int32_t diff_sec = endTimer . tv_sec - startTimer . tv_sec ; int32_t diff_nsec = endTimer . tv_nsec - startTimer . tv_nsec ; if ( diff_nsec < 0 ) { diff_nsec = 1000000000 - diff_nsec ; diff_sec -= 1 ; } cout << \"Received 1000000 bytes in \" << diff_sec << \".\" << diff_nsec << \" seconds\" << endl ; } Compile the source code: g++ -Ofast -Wall -pthread rf24_rx.cpp -lrf24 -o rf24_rx Run it and see the log: ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO15 SPI Speedz = 10 Mhz ================ NRF Configuration ================ STATUS = 0x0e RX_DR=0 TX_DS=0 MAX_RT=0 RX_P_NO=7 TX_FULL=0 RX_ADDR_P0-1 = 0x65646f4e31 0x7264644131 RX_ADDR_P2-5 = 0xc3 0xc4 0xc5 0xc6 TX_ADDR = 0x65646f4e31 RX_PW_P0-6 = 0x20 0x20 0x20 0x20 0x20 0x20 EN_AA = 0x3f EN_RXADDR = 0x03 RF_CH = 0x64 RF_SETUP = 0x03 CONFIG = 0x0e DYNPD/FEATURE = 0x00 0x00 Data Rate = 1 MBPS Model = nRF24L01+ CRC Length = 16 bits PA Power = PA_LOW ARC = 0 ================ SPI Configuration ================ CSN Pin = /dev/spidev0.0 CE Pin = Custom GPIO15 SPI Frequency = 10 Mhz ================ NRF Configuration ================ Channel = 100 (~ 2500 MHz) RF Data Rate = 1 MBPS RF Power Amplifier = PA_LOW RF Low Noise Amplifier = Enabled CRC Length = 16 bits Address Length = 5 bytes Static Payload Length = 32 bytes Auto Retry Delay = 1500 microseconds Auto Retry Attempts = 15 maximum Packets lost on current channel = 0 Retry attempts made for last transmission = 0 Multicast = Disabled Custom ACK Payload = Disabled Dynamic Payloads = Disabled Auto Acknowledgment = Enabled Primary Mode = TX TX address = 0x65646f4e31 pipe 0 ( open ) bound = 0x65646f4e31 pipe 1 ( open ) bound = 0x7264644131 pipe 2 (closed) bound = 0xc3 pipe 3 (closed) bound = 0xc4 pipe 4 (closed) bound = 0xc5 pipe 5 (closed) bound = 0xc6 Start RX Begin: 793.156527770 End: 821.645141301 Received 1000000 bytes in 28.488613531 seconds The example receives 1 MB in 28.5 seconds, which means 35 KBps. While the transfer rate set on the channel is 1Mbps (equals 125 KBps), the example only achieve 28% of bandwidth.","title":"6. nRF24L01p driver"},{"location":"rover/#7-oled-driver","text":"Download source code and build: git clone https://github.com/vuquangtrong/OLED_SSD1306_I2C_Linux.git && \\ cd OLED_SSD1306_I2C_Linux && \\ make && \\ sudo make install Write a simple app to a progress bar with label and numeric value: progress_bar.c #include <string.h> #include <unistd.h> #include <SSD1306/ssd1306.h> int main () { char counter = 0 ; char buffer [ 3 ]; SSD1306_Init ( \"/dev/i2c-1\" ); while ( 1 ) { sprintf ( buffer , \"%d\" , counter ++ ); SSD1306_Clear (); SSD1306_WriteString ( 0 , 0 , \"counter:\" , & Font_7x10 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_WriteString ( 0 , 10 , buffer , & Font_11x18 , SSD1306_WHITE , SSD1306_OVERRIDE ); SSD1306_DrawRectangle ( 0 , 28 , 128 , 4 , SSD1306_WHITE ); SSD1306_DrawFilledRectangle ( 0 , 28 , counter * 128 / 256 , 4 , SSD1306_WHITE ); SSD1306_Screen_Update (); sleep ( 0.2 ); } return 0 ; } Compile and run: gcc progress_bar.c -lssd1306 -o progress_bar && \\ ./progress_bar","title":"7. OLED driver"},{"location":"rover/#8-ros-melodic","text":"Adding repository and source list sudo apt-add-repository universe sudo apt-add-repository multiverse sudo apt-add-repository restricted sudo apt update Setup source list to get ROS packages: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Add keys: sudo apt install -y curl && \\ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Pull the package list: sudo apt update Install ROS Melodic desktop: sudo apt install -y ros-melodic-desktop It's convenient if the ROS environment variables are automatically added to a bash session every time a new shell is launched: echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc && \\ source ~/.bashrc A good way to check the installation is to ensure that environment variables like ROS_ROOT and ROS_PACKAGE_PATH are set: printenv | grep ROS ROS_ETC_DIR = /opt/ros/melodic/etc/ros ROS_ROOT = /opt/ros/melodic/share/ros ROS_MASTER_URI = http://localhost:11311 ROS_VERSION = 1 ROS_PYTHON_VERSION = 2 ROS_PACKAGE_PATH = /opt/ros/melodic/share ROSLISP_PACKAGE_DIRECTORIES = ROS_DISTRO = melodic Initialize the package rosdep to track package dependency: sudo apt install python-rosdep -y && \\ sudo rosdep init && \\ rosdep update Build packages are needed for code compilation. sudo apt install -y python-rosinstall python-rosinstall-generator python-wstool build-essential Create a catkin workspace and try to build it: mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src catkin_init_workspace cd .. catkin_make The workspace should be built successfully.","title":"8. ROS Melodic"},{"location":"rover/#9-livox-sdk","text":"","title":"9. Livox SDK"},{"location":"rover/#91-dependencies","text":"Livox SDK needs to be built in the host machine, therefore, some tool-chain and build tools have to be installed. sudo apt-get update && \\ sudo apt-get install -y build-essential && \\ sudo apt-get install -y curl && \\ sudo apt-get install -y git && \\ sudo apt-get install -y cmake The Point Cloud Library (PCL) is a large scale, open project[1] for point cloud processing. The PCL framework contains numerous state-of-the art algorithms including filtering, feature estimation, surface reconstruction, registration, model fitting and segmentation. sudo apt install -y libpcl-dev sudo apt install -y ros-melodic-pcl-ros Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms. sudo apt install -y libeigen3-dev OpenCV (Open Source Computer Vision Library) is an open-source computer vision library and has bindings for C++, Python, and Java. It is used for a very wide range of applications, including medical image analysis, stitching street view images, surveillance video, detecting and recognizing faces, tracking moving objects, extracting 3D models, and much more. OpenCV can take advantage of multi-core processing and features GPU acceleration for real-time operation. sudo apt install -y python-opencv python3-opencv Re-link libraries: sudo ln -s /usr/bin/vtk6 /usr/bin/vtk && \\ sudo ln -s /usr/lib/python2.7/dist-packages/vtk/libvtkRenderingPythonTkWidgets.aarch64-linux-gnu.so /usr/lib/aarch64-linux-gnu/libvtkRenderingPythonTkWidgets.so","title":"9.1. Dependencies"},{"location":"rover/#92-livox-sdk","text":"The official guide is at https://github.com/Livox-SDK/Livox-SDK . Livox SDK is the software development kit designed for all Livox products. It is developed based on C/C++ following Livox SDK Communication Protocol, and provides easy-to-use C style API. With Livox SDK, users can quickly connect to Livox products and receive point cloud data. Installation git clone https://github.com/Livox-SDK/Livox-SDK.git && \\ cd Livox-SDK && \\ cd build && \\ cmake .. && \\ make && \\ sudo make install The Livox SDK will be built and installed in /usr/local/lib : Install the project... -- Install configuration: \"\" -- Installing: /usr/local/lib/liblivox_sdk_static.a -- Installing: /usr/local/include/livox_def.h -- Installing: /usr/local/include/livox_sdk.h","title":"9.2. Livox SDK"},{"location":"rover/#10-livox-ros-driver","text":"Get livox_ros_driver from GitHub git clone https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src Then build it: cd ws_livox && \\ catkin_make If running catkin_make gives error of command not found, it's probably that the ROS setup.bash is not executed and included in ~/.bashrc . See above section to source it. This driver will create a new node named livox_lidar_publisher , which publishes 2 new types of messages: Livox Point Cloud message # Livox publish pointcloud msg format. Header header # ROS standard message header uint64 timebase # The time of first point uint32 point_num # Total number of pointclouds uint8 lidar_id # Lidar device id number uint8 [ 3 ] rsvd # Reserved use CustomPoint [] points # Pointcloud data Livox Point # Livox custom pointcloud format. uint32 offset_time # offset time relative to the base time float32 x # X axis, unit:m float32 y # Y axis, unit:m float32 z # Z axis, unit:m uint8 reflectivity # reflectivity, 0~255 uint8 tag # livox tag uint8 line # laser number in lidar","title":"10. Livox ROS driver"},{"location":"rover/#101-configurations","text":"The configuration file is in ws_livox/src/livox_ros_driver/config . LiDAR's configuration parameter Parameter Type Description Default broadcast_code String LiDAR broadcast code N/A enable_connect Boolean false return_mode Int Return mode: 0 -- First single return mode 1 -- The strongest single return mode 2 -- Dual return mode 0 coordinate Int Coordinate: 0 -- Cartesian 1 -- Spherical 0 imu_rate Int Push frequency of IMU sensor data: 0 -- stop push 1 -- 200 Hz Currently only Horizon supports this, MID serials do not support it 0 extrinsic_parameter_source Int Whether to enable extrinsic parameter automatic compensation of LiDAR external reference 0 -- Disabled 1 -- Enabled 0 Timestamp synchronization Parameter Type Description Default enable_timesync Boolean false device_name String Name of the serial device which outputs GPRMC/GNRMC messages every second /dev/ttyUSB0 comm_device_type Int Type of device sending timestamp information 0 -- Serial port or USB virtual serial port device other -- not support 0 baudrate_index Int Baud rate of serial device: 0 -- 2400 1 -- 4800 2 -- 9600 3 -- 19200 4 -- 38400 5 -- 57600 6 -- 115200 7 -- 230400 8 -- 460800 9 -- 500000 10 -- 576000 11 -- 921600 2 (9600) parity_index Int parity type 0 -- 8 bits data without parity 1 -- 7 bits data 1bit even parity 2 -- 7 bits data 1bit odd parity 3 -- 7 bits data 1bit 0, without parity 0 livox_lidar_config.json { \"lidar_config\" : [ { \"broadcast_code\" : \"1PQDH5B00100041\" , \"enable_connect\" : false , \"return_mode\" : 0 , \"coordinate\" : 0 , \"imu_rate\" : 0 , \"extrinsic_parameter_source\" : 0 , \"enable_high_sensitivity\" : false } ], \"timesync_config\" : { \"enable_timesync\" : false , \"device_name\" : \"/dev/ttyUSB0\" , \"comm_device_type\" : 0 , \"baudrate_index\" : 2 , \"parity_index\" : 0 } }","title":"10.1. Configurations"},{"location":"rover/#102-timestamp","text":"Prepare a GPS device to ensure that the GPS can output UTC time information in GPRMC/GNRMC format through the serial port or USB virtual serial port, and support PPS signal output. Connect the GPS serial port to the host running livox_ros_driver , set the corresponding device name in the config file Connect the GPS PPS signal line to LiDAR Be sure to set the output frequency of GPRMC/GNRMC time information of GPS to 1Hz","title":"10.2. Timestamp"},{"location":"rover/#103-launches","text":"Different launch files have different configuration parameter values and are used in different scenarios: Launch file name Description livox_lidar.launch Connect to Livox LiDAR device Publish pointcloud2 format data livox_lidar_msg.launch Connect to Livox LiDAR device Publish livox customized pointcloud data livox_lidar_rviz.launch Connect to Livox LiDAR device Publish pointcloud2 format data Autoload rviz Launch parameters Parameter Description Default publish_freq Set the frequency of point cloud publish 10.0 multi_topic 0 -- All LiDAR devices use the same topic to publish point cloud data 1 -- Each LiDAR device has its own topic to publish point cloud data 0 xfer_format 0 -- Livox pointcloud2 ( PointXYZRTL ) point cloud format 1 -- Livox customized point cloud format 2 -- Standard pointcloud2 ( PointXYZI ) point cloud format in the PCL library 0","title":"10.3. Launches"},{"location":"rover/#104-test-ros","text":"An easy method to connect Livox Lidar with Jetson board is through a LAN router. Below section shows another method to connect 2 modules directly. Set Livox's Static IP Use Livox Viewer to set a Static IP for the Lidar module. Livox only accepts IP in 192.168.1.0 network. Set Jetson's Static IP sudo nano /etc/network/interfaces /etc/network/interfaces auto lo iface lo inet loopback auto eth0 iface eth0 inet static address 192.168.1.12 netmask 255.255.255.0 Then run the livox_lidar_rviz example cd ws_livox source ./devel/setup.bash roslaunch livox_ros_driver livox_lidar_rviz.launch This will run Livox ROS and Rviz to visualize the received pointcloud.","title":"10.4. Test ROS"},{"location":"rover/#11-auto-mount-usb","text":"Check out and install: git clone https://github.com/vuquangtrong/USB_Automount.git cd USB_Automount ./install Plugged-in USB will be mounted into /media/<Label> or /media/<sdXy> . Details Here are scripts to auto-mount storage devices: sudo nano /usr/local/bin/usb-mount.sh usb-mount.sh #!/bin/bash # This script is called from our systemd unit file to mount or unmount # a USB drive. usage () { echo \"Usage: $0 {add|remove} device_name (e.g. sdb1)\" exit 1 } if [[ $# -ne 2 ]] ; then usage fi ACTION = $1 DEVBASE = $2 DEVICE = \"/dev/ ${ DEVBASE } \" # See if this drive is already mounted, and if so where MOUNT_POINT = $( /bin/mount | /bin/grep ${ DEVICE } | /usr/bin/awk '{ print $3 }' ) do_mount () { if [[ -n ${ MOUNT_POINT } ]] ; then echo \"Warning: ${ DEVICE } is already mounted at ${ MOUNT_POINT } \" exit 1 fi # Get info for this drive: $ID_FS_LABEL, $ID_FS_UUID, and $ID_FS_TYPE eval $( /sbin/blkid -o udev ${ DEVICE } ) # Figure out a mount point to use LABEL = ${ ID_FS_LABEL } if [[ -z \" ${ LABEL } \" ]] ; then LABEL = ${ DEVBASE } elif /bin/grep -q \" /media/ ${ LABEL } \" /etc/mtab ; then # Already in use, make a unique one LABEL += \"- ${ DEVBASE } \" fi MOUNT_POINT = \"/media/ ${ LABEL } \" echo \"Mount point: ${ MOUNT_POINT } \" /bin/mkdir -p ${ MOUNT_POINT } # Global mount options OPTS = \"rw,relatime\" # File system type specific mount options if [[ ${ ID_FS_TYPE } == \"vfat\" ]] ; then OPTS += \",users,gid=100,umask=000,shortname=mixed,utf8=1,flush\" fi if ! /bin/mount -o ${ OPTS } ${ DEVICE } ${ MOUNT_POINT } ; then echo \"Error mounting ${ DEVICE } (status = $? )\" /bin/rmdir ${ MOUNT_POINT } exit 1 fi echo \"**** Mounted ${ DEVICE } at ${ MOUNT_POINT } ****\" } do_unmount () { if [[ -z ${ MOUNT_POINT } ]] ; then echo \"Warning: ${ DEVICE } is not mounted\" else /bin/umount -l ${ DEVICE } echo \"**** Unmounted ${ DEVICE } \" fi # Delete all empty dirs in /media that aren't being used as mount # points. This is kind of overkill, but if the drive was unmounted # prior to removal we no longer know its mount point, and we don't # want to leave it orphaned... for f in /media/* ; do if [[ -n $( /usr/bin/find \" $f \" -maxdepth 0 -type d -empty ) ]] ; then if ! /bin/grep -q \" $f \" /etc/mtab ; then echo \"**** Removing mount point $f \" /bin/rmdir \" $f \" fi fi done } case \" ${ ACTION } \" in add ) do_mount ;; remove ) do_unmount ;; * ) usage ;; esac Change permission: sudo chmod 0755 /usr/local/bin/usb-mount.sh Add service: sudo nano /etc/systemd/system/usb-mount@.service usb-mount@.service [Unit] Description = Mount USB Drive on %i [Service] Type = oneshot RemainAfterExit = true ExecStart = /usr/local/bin/usb-mount.sh add %i ExecStop = /usr/local/bin/usb-mount.sh remove %i The file name uses @ to pass arguments. Add rules for udev when USB event is detected: sudo nano /etc/udev/rules.d/99-usb-mount.rules 99-usb-mount.rules KERNEL = =\"sd[a-z][0-9]\", SUBSYSTEMS==\"usb\", ACTION==\"add\", RUN+=\"/bin/systemctl start usb-mount@%k.service\" KERNEL = =\"sd[a-z][0-9]\", SUBSYSTEMS==\"usb\", ACTION==\"remove\", RUN+=\"/bin/systemctl stop usb-mount@%k.service\" Restart services and rules: sudo udevadm control --reload-rules && \\ sudo systemctl daemon-reload If a USB is not mount automatically, check the system log: cat /var/log/syslog","title":"11. Auto-mount USB"},{"location":"rover/#12-auto-start-application","text":"A simple app that shows IP Address on OLED screen. ipshow.cpp #include <iostream> #include <string> #include <cstring> #include <sys/socket.h> #include <netinet/in.h> #include <arpa/inet.h> #include <unistd.h> #include <sys/types.h> #include <ifaddrs.h> #include <SSD1306/ssd1306.h> using namespace std ; char i2c_dev [] = \"/dev/i2c-1\" ; char noIP [] = \"No IP\" ; void showIP ( int line , char type , char * ip ) { char buffer [ 32 ] = { 0 }; sprintf ( buffer , \"%c:%s\" , type , ip ); SSD1306_WriteString ( 0 , line * 10 , buffer , & Font_7x10 , SSD1306_WHITE , SSD1306_OVERRIDE ); } void getIPAddresses () { struct ifaddrs * interfaces = NULL ; struct ifaddrs * temp_addr = NULL ; int success = 0 ; bool found = false ; // retrieve the current interfaces - returns 0 on success success = getifaddrs ( & interfaces ); if ( success == 0 ) { // Loop through linked list of interfaces temp_addr = interfaces ; while ( temp_addr != NULL ) { if ( temp_addr -> ifa_addr -> sa_family == AF_INET ) { // Check if interface is en0 which is the wifi connection on the iPhone if ( strcmp ( temp_addr -> ifa_name , \"wlan0\" ) == 0 ){ showIP ( 0 , 'W' , inet_ntoa ((( struct sockaddr_in * ) temp_addr -> ifa_addr ) -> sin_addr ) ); found = true ; } if ( strcmp ( temp_addr -> ifa_name , \"eth0\" ) == 0 ){ showIP ( 1 , 'E' , inet_ntoa ((( struct sockaddr_in * ) temp_addr -> ifa_addr ) -> sin_addr ) ); found = true ; } } temp_addr = temp_addr -> ifa_next ; } } // Free memory freeifaddrs ( interfaces ); if ( ! found ) { showIP ( 3 , '?' , noIP ); } } int main ( int argc , char ** argv ) { SSD1306_Init ( i2c_dev ); while ( 1 ) { SSD1306_Clear (); getIPAddresses (); SSD1306_Screen_Update (); sleep ( 10 ); } } Create a service: ipshow.service [Unit] Description = IP Show After = multi-user.target [Service] Type = simple ExecStart = /usr/bin/ipshow [Install] WantedBy = multi-user.target Enable the service: sudo systemctl enable ipshow.service","title":"12. Auto-start application"}]}